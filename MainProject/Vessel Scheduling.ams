## ams_version=1.0

Model Main_Vessel_Schedule {
	Section Data_Model {
		Section Quantities_and_Units {
			Comment: {
				"This section contains all the units and quantities that are added automatically by AIMMS.
				It is recommended to declare all your quantities here."
			}
			Quantity SI_Time_Duration {
				BaseUnit: s;
				Conversions: {
					day->s : #-># * 86400,
					minute->s : #-># * 60,
					century->s : #-># * 3153600000,
					year->s : #-># * 31536000,
					month->s : #-># * 2628000,
					week->s : #-># * 604800,
					hour->s : #-># * 3600,
					tick->s : #-># / 100,
					second->s : #->#
				}
				Comment: "Expresses the value for the duration of periods.";
			}
			Quantity Q_Currency {
				BaseUnit: $;
			}
		}
		Section Calendars {
			Calendar cal_days {
				Index: i_day;
				Unit: day;
				BeginDate: sp_def_beginDate;
				EndDate: sp_def_endDate;
				TimeslotFormat: "%c%y-%m-%d";
			}
			ElementParameter ep_startHorizonDate {
				Range: cal_days;
			}
			StringParameter sp_def_beginDate {
				Definition: "2000-01-01";
			}
			StringParameter sp_def_endDate {
				Definition: "2099-12-31";
			}
		}
		Section Cargoes {
			Set s_cargoes {
				Index: i_cargo_aux;
				Parameter: ep_cargo;
			}
			Index i_cargo {
				Range: s_cargoes;
				dex::ColumnName: Cargo;
			}
			Set s_def_activeCargoes {
				SubsetOf: s_cargoes;
				Index: i_act_cargo, i_act_cargo_aux;
				Definition: {
					{i_cargo | bp_activeCargoes(i_cargo)}
				}
			}
			Parameter bp_activeCargoes {
				IndexDomain: i_cargo;
				Range: binary;
				InitialData: 1;
			}
			Parameter p_spotCostVessel {
				IndexDomain: i_cargo;
				Unit: $;
				Comment: "todo: what this is?";
				dex::ColumnName: Spotcost on Vessel;
				dex::Dataset: Import;
				dex::TableName: CargoData;
			}
			ElementParameter ep_minTimeWindow {
				IndexDomain: i_cargo;
				Range: cal_days;
				dex::ColumnName: Minimum Loading Time;
				dex::Dataset: Import;
				dex::TableName: CargoData;
			}
			ElementParameter ep_maxTimeWindow {
				IndexDomain: i_cargo;
				Range: cal_days;
				dex::ColumnName: Maximum Loading Time;
				dex::Dataset: Import;
				dex::TableName: CargoData;
			}
			ElementParameter ep_loadingPortsCargo {
				IndexDomain: i_cargo;
				Range: s_locations;
				dex::ColumnName: Loading Port;
				dex::Dataset: Import;
				dex::TableName: CargoData;
			}
			ElementParameter ep_deliveringPortsCargo {
				IndexDomain: i_cargo;
				Range: s_locations;
				dex::ColumnName: Delevering Port;
				dex::Dataset: Import;
				dex::TableName: CargoData;
			}
			Parameter p_cargoCost {
				IndexDomain: (i_cargo,i_ct) | bp_activeCostsForCargoes(i_ct);
				Range: free;
				Unit: up_def_costUnit(i_ct);
				dex::ColumnName: Type Costs;
				dex::Dataset: Import;
				dex::TableName: CargoCosts;
			}
			Set s_def_loadingPorts {
				SubsetOf: s_locations;
				Index: i_locLoad;
				Definition: {
					{i_loc | exists(i_cargo | i_loc = ep_loadingPortsCargo(i_cargo))}
				}
			}
			Set s_def_deleveringPorts {
				SubsetOf: s_locations;
				Index: i_locDeliv;
				Definition: {
					{i_loc | exists(i_cargo | i_loc = ep_deliveringPortsCargo(i_cargo))}
				}
			}
			Set s_def_vesselOriginPorts {
				SubsetOf: s_locations;
				Index: i_locVess;
				Definition: {
					{i_loc | exists(i_act_vessel | i_loc = ep_originPortOfVessel(i_act_vessel))}
				}
			}
			Parameter p_def_minTimeWindow {
				IndexDomain: i_cargo;
				Unit: day;
				Definition: StringToMoment("%c%y-%m-%d", [day], ep_startHorizonDate, ep_minTimeWindow(i_cargo));
			}
			Parameter p_def_maxTimeWindow {
				IndexDomain: i_cargo;
				Unit: day;
				Definition: StringToMoment("%c%y-%m-%d", [day], ep_startHorizonDate, ep_maxTimeWindow(i_cargo));
			}
		}
		Section Vessels {
			Set s_vessels {
				Parameter: ep_vessel;
			}
			Index i_vessel {
				Range: s_vessels;
				dex::ColumnName: Vessel;
			}
			Set s_def_activeVessels {
				SubsetOf: s_vessels;
				Index: i_act_vessel;
				Definition: {
					{i_vessel | bp_activeVessels(i_vessel)}
				}
			}
			Parameter bp_activeVessels {
				IndexDomain: i_vessel;
				Range: binary;
				InitialData: 1;
			}
			ElementParameter ep_originPortOfVessel {
				IndexDomain: i_vessel;
				Range: s_locations;
				dex::ColumnName: Port of Origin;
				dex::Dataset: Import;
				dex::TableName: VesselData;
			}
			Parameter p_vesselCost {
				IndexDomain: (i_vessel,i_ct) | bp_activeCostsForVessels(i_ct);
				Unit: up_def_costUnit(i_ct);
				Comment: {
					"! Fuel usage per day is 63000 gallons = 238000 liter -> 238000/100000 * â‚¬601 = 1433"
				}
				dex::ColumnName: DailyCost;
				dex::Dataset: Import;
				dex::TableName: VesselCosts;
			}
		}
		Section Cost_Types {
			Set s_costTypes {
				Parameter: ep_costType;
			}
			Set s_def_costUnit {
				Index: i_ct_unit;
				Definition: {
					{'$', '$/day'}
				}
			}
			Index i_ct {
				Range: s_costTypes;
				dex::ColumnName: Cost Type;
			}
			ElementParameter ep_costUnit {
				IndexDomain: i_ct;
				Range: s_def_costUnit;
			}
			UnitParameter up_def_costUnit {
				IndexDomain: i_ct;
				Definition: StringToUnit(ep_costUnit(i_ct));
			}
			Parameter bp_def_isCostPerDay {
				IndexDomain: i_ct;
				Definition: 1 $ (ep_costUnit(i_ct) = '$/day');
			}
			Parameter bp_def_isNotCostPerDay {
				IndexDomain: i_ct;
				Definition: 1 $ (ep_costUnit(i_ct) = '$');
			}
			Set s_def_costTypesForCargoes {
				SubsetOf: s_costTypes;
				Index: i_ct_cargo;
				Definition: {
					{i_ct | bp_activeCostsForCargoes(i_ct)}
				}
			}
			Set s_def_costsForCargoes {
				SubsetOf: s_costTypes;
				Index: i_act_ct_cargo;
				Definition: {
					{i_ct | bp_activeCostsForCargoes(i_ct)}
				}
			}
			Parameter bp_activeCostsForCargoes {
				IndexDomain: i_ct;
				Range: binary;
				dex::ColumnName: Cargoes;
				dex::Dataset: Import;
				dex::TableName: Type Cost Group;
			}
			Set s_def_costTypesForVessels {
				SubsetOf: s_costTypes;
				Index: i_act_ct_vessel;
				Definition: {
					{i_ct | bp_activeCostsForVessels(i_ct)}
				}
			}
			Parameter bp_activeCostsForVessels {
				IndexDomain: i_ct;
				Range: binary;
				dex::ColumnName: Vessel;
				dex::Dataset: Import;
				dex::TableName: Type Cost Group;
			}
			Set s_def_costTypesForLocations {
				SubsetOf: s_costTypes;
				Index: i_act_ct_loc;
				Definition: {
					{i_ct | bp_activeCostsForLocations(i_ct)}
				}
			}
			Parameter bp_activeCostsForLocations {
				IndexDomain: i_ct;
				Range: binary;
				dex::ColumnName: Location;
				dex::Dataset: Import;
				dex::TableName: Type Cost Group;
			}
		}
		Section Locations {
			Set s_locations {
				Parameter: ep_location;
			}
			Index i_loc {
				Range: s_locations;
				dex::ColumnName: Location;
			}
			Index i_loc_from {
				Range: s_locations;
				dex::ColumnName: Location (From);
			}
			Index i_loc_to {
				Range: s_locations;
				dex::ColumnName: Location (To);
			}
			Set s_def_activeLocations {
				SubsetOf: s_locations;
				Index: i_act_loc;
				Definition: {
					{i_loc | bp_activeLocations(i_loc)}
				}
			}
			Parameter bp_activeLocations {
				IndexDomain: i_loc;
				Range: binary;
				InitialData: 1;
			}
			Parameter p_latitude {
				IndexDomain: i_loc;
				dex::ColumnName: Latitude;
				dex::Dataset: Import;
				dex::TableName: LocationData;
			}
			Parameter p_longitude {
				IndexDomain: i_loc;
				dex::ColumnName: Longitude;
				dex::Dataset: Import;
				dex::TableName: LocationData;
			}
			Parameter p_idleCostLocation {
				IndexDomain: i_loc;
				Unit: $/day;
				dex::ColumnName: Idle Cost;
				dex::Dataset: Import;
				dex::TableName: LocationData;
			}
			Parameter p_locationCost {
				IndexDomain: (i_loc,i_ct) | bp_activeCostsForLocations(i_ct);
				Unit: up_def_costUnit(i_ct);
				dex::ColumnName: Costs;
				dex::Dataset: Import;
				dex::TableName: LocationCosts;
			}
			Parameter p_distanceBetweenLocations {
				IndexDomain: (i_loc_from,i_loc_to)| i_loc_from <> i_loc_to;
				Unit: day;
				dex::ColumnName: DeleveringLocation;
				dex::Dataset: Import;
				dex::TableName: DistanceBetweenLocations;
			}
		}
		Section Routes {
			Set s_calc_feasibleRoutes {
				Index: i_route;
				Parameter: ep_route;
			}
			ElementParameter ep_calc_vesselOnRoute {
				IndexDomain: i_route;
				Range: s_def_activeVessels;
				webui::FlagsIdentifier: ui::sp_def_readOnly;
			}
			Parameter p_calc_totalRouteLocationCost {
				IndexDomain: i_route;
				Unit: $;
			}
			Parameter p_calc_loadingTimeCargoRoute {
				IndexDomain: (i_act_cargo,i_route);
				Unit: day;
				webui::FlagsIdentifier: ui::sp_def_readOnly;
			}
			StringParameter sp_calc_cargoesOnRoute {
				IndexDomain: i_route;
				webui::FlagsIdentifier: ui::sp_def_readOnly;
			}
			Parameter p_calc_cargoesOnRoute {
				IndexDomain: (i_route,i_cargo);
				Range: nonnegative;
			}
			Parameter p_calc_totalDaysTravelPerRoute {
				IndexDomain: i_route;
				Unit: day;
				webui::FlagsIdentifier: ui::sp_def_readOnly;
			}
			Parameter p_calc_totalRouteIdleCost {
				IndexDomain: (i_route);
				Unit: $;
			}
			Parameter bp_def_cargoesOnRoute {
				IndexDomain: (i_route,i_act_cargo);
				Range: binary;
				Definition: 1 $ p_calc_cargoesOnRoute(i_route,i_act_cargo);
			}
			Parameter p_def_totalRouteMovementCost {
				IndexDomain: i_route;
				Unit: $;
				Definition: {
					p_calc_totalDaysTravelPerRoute(i_route) 
					* sum(i_ct, p_vesselCost(ep_calc_vesselOnRoute(i_route), i_ct))
				}
			}
			Parameter p_def_deleveringTimeCargoRoute {
				IndexDomain: (i_act_cargo,i_route) | p_calc_cargoesOnRoute(i_route,i_act_cargo);
				Unit: day;
				Definition: {
					(p_calc_loadingTimeCargoRoute(i_act_cargo, i_route) 
					+ p_distanceBetweenLocations(ep_loadingPortsCargo(i_act_cargo), ep_deliveringPortsCargo(i_act_cargo)))
				}
				webui::FlagsIdentifier: ui::sp_def_readOnly;
			}
			Procedure pr_calculateRoutesAndCostAfterSomeChangesFromGabi {
				Body: {
					empty s_calc_feasibleRoutes;
					empty p_calc_cargoesOnRoute;
					
					!Assumption: when a vessel is used, and the time horizon starts, 
					!the vessel will always directly move to the loading port of the cargo.
					
					p_loc_travelTimeCargoes(i_cargo, i_cargo_aux) 
					:=  p_distanceBetweenLocations(ep_loadingPortsCargo(i_cargo),ep_deliveringPortsCargo(i_cargo)) 
					    + p_distanceBetweenLocations(ep_deliveringPortsCargo(i_cargo),ep_loadingPortsCargo(i_cargo_aux));
					
					for i_act_vessel do
					
					    p_loc_loopCount := 1;
					
					    for i_act_cargo do
					
					        SetElementAdd(s_calc_feasibleRoutes, ep_route, i_act_vessel + "_" + i_act_cargo);
					        ep_loc_lastCargoFromRoute(ep_route) := i_act_cargo;
					        ep_calc_vesselOnRoute(ep_route) := i_act_vessel;
					        p_calc_cargoesOnRoute(ep_route, i_act_cargo) := 1;
					        p_loc_quantityOfCargos(ep_route) := 1;
					        sp_calc_cargoesOnRoute(ep_route) := i_act_cargo;
					
					        !Total days for first delivery
					        p_calc_totalDaysTravelPerRoute(ep_route) 
					        :=  p_distanceBetweenLocations(ep_originPortOfVessel(i_act_vessel), ep_loadingPortsCargo(i_act_cargo))
					            + p_distanceBetweenLocations(ep_loadingPortsCargo(i_act_cargo), ep_deliveringPortsCargo(i_act_cargo));
					
					        bp_calc_routeLocations(ep_route, ep_loadingPortsCargo(i_act_cargo)) := 1;
					        bp_calc_routeLocations(ep_route, ep_deliveringPortsCargo(i_act_cargo)) := 1;
					        bp_calc_routeLocations(ep_route, ep_originPortOfVessel(i_act_vessel)) := 1;
					
					        !Cargo cost
					        p_calc_totalCargoDailyCost(ep_route) 
					        :=  sum(i_act_ct_cargo | bp_def_isCostPerDay(i_act_ct_cargo), 
					                    p_distanceBetweenLocations(ep_loadingPortsCargo(i_act_cargo), ep_deliveringPortsCargo(i_act_cargo))
					                    * p_cargoCost(i_act_cargo, i_act_ct_cargo));
					
					        p_calc_totalCargoFixedCost(ep_route) := sum(i_act_ct_cargo | not bp_def_isCostPerDay(i_act_ct_cargo), p_cargoCost(i_act_cargo, i_act_ct_cargo));
					
					        !Vessel cost
					        p_calc_totalVesselDailyCost(ep_route) 
					        :=  sum(i_act_ct_vessel | bp_def_isCostPerDay(i_act_ct_vessel), 
					                    p_calc_totalDaysTravelPerRoute(ep_route)
					                    * p_vesselCost(ep_calc_vesselOnRoute(ep_route), i_act_ct_vessel));
					
					        p_calc_totalVesselFixedCost(ep_route) := sum(i_act_ct_vessel | not bp_def_isCostPerDay(i_act_ct_vessel), p_vesselCost(ep_calc_vesselOnRoute(ep_route), i_act_ct_vessel));
					
					        !Location cost
					        p_calc_totalLocationFixedCost(ep_route) 
					        :=  sum((i_act_ct_loc, i_loc) | 
					                        not bp_def_isCostPerDay(i_act_ct_loc)
					                        and bp_calc_routeLocations(ep_route, i_loc), 
					                    p_locationCost(i_loc, i_act_ct_loc));
					
					
					        !Cannot come earlier then arrival time
					        p_loc_lastLoadArrivalTime(ep_route) |
					                (p_distanceBetweenLocations(ep_originPortOfVessel(i_act_vessel), ep_loadingPortsCargo(i_act_cargo)) 
					                <= p_def_minTimeWindow(i_act_cargo))
					        :=  p_def_minTimeWindow(i_act_cargo);
					
					        p_loc_lastLoadArrivalTime(ep_route) |
					                (p_def_minTimeWindow(i_act_cargo) 
					                <= p_distanceBetweenLocations(ep_originPortOfVessel(i_act_vessel), ep_loadingPortsCargo(i_act_cargo)) 
					                <= p_def_maxTimeWindow(i_act_cargo))
					        :=  p_distanceBetweenLocations(ep_originPortOfVessel(i_act_vessel), ep_loadingPortsCargo(i_act_cargo));
					
					
					        !Loading and delivering time
					        p_calc_loadingTimeCargoRoute(i_act_cargo, ep_route) |
					                (p_distanceBetweenLocations(ep_originPortOfVessel(i_act_vessel), ep_loadingPortsCargo(i_act_cargo)) 
					                <= p_def_minTimeWindow(i_act_cargo))
					        :=  p_def_minTimeWindow(i_act_cargo);
					
					        p_calc_loadingTimeCargoRoute(i_act_cargo, ep_route) |
					                (p_def_minTimeWindow(i_act_cargo) 
					                <= p_distanceBetweenLocations(ep_originPortOfVessel(i_act_vessel), ep_loadingPortsCargo(i_act_cargo)) 
					                <= p_def_maxTimeWindow(i_act_cargo))
					        :=  p_distanceBetweenLocations(ep_originPortOfVessel(i_act_vessel), ep_LoadingPortsCargo(i_act_cargo));
					
					
					
					        !Extra deliver arrival time NAO ENTENDI
					        p_loc_lastDeliverArrivalTime(ep_route)
					        :=  p_loc_lastLoadArrivalTime(ep_route) 
					            + p_distanceBetweenLocations(ep_loadingPortsCargo(i_act_cargo), ep_deliveringPortsCargo(i_act_cargo));
					
					!        !Idle cost until cargo pickup OK
					!        p_calc_totalRouteIdleCost(ep_route) 
					!        :=  p_idleCostLocation(ep_loadingPortsCargo(i_act_cargo)) 
					!            * p_distanceBetweenLocations(ep_originPortOfVessel(i_act_vessel), ep_loadingPortsCargo(i_act_cargo));
					
					    endfor;
					
					    repeat 
					
					        !Select all routes that are equal to the loop count and to the correct vessel
					        s_loc_subRoutes 
					        :=  {i_route | 
					                    p_loc_quantityOfCargos(i_route) = p_loc_loopCount 
					                    and ep_calc_vesselOnRoute(i_route) = i_act_vessel}; 
					
					        !Statement to break out of the loop
					        if card(s_loc_subRoutes) = 0 then
					            break;
					        endif;
					
					        p_loc_travelTimeLowerThanMinimum(i_loc_sub_route, i_act_cargo)
					        :=  1 $ (p_loc_travelTimeCargoes(ep_loc_lastCargoFromRoute(i_loc_sub_route), i_act_cargo) 
					                + p_loc_lastLoadArrivalTime(i_loc_sub_route) 
					                <= p_def_minTimeWindow(i_act_cargo));
					
					        p_loc_travelTimeInBetween(i_loc_sub_route, i_act_cargo) 
					        :=  1 $ (p_def_minTimeWindow(i_act_cargo) 
					                <= p_loc_travelTimeCargoes(ep_loc_lastCargoFromRoute(i_loc_sub_route), i_act_cargo) 
					                + p_loc_lastLoadArrivalTime(i_loc_sub_route) 
					                <= p_def_maxTimeWindow(i_act_cargo));
					
					        !Only cargoes that are not on the route yet
					        for (i_loc_sub_route,i_act_cargo) | 
					                    p_calc_cargoesOnRoute(i_loc_sub_route, i_act_cargo) = 0 
					                    and (p_loc_travelTimeLowerThanMinimum(i_loc_sub_route, i_act_cargo) 
					                        or p_loc_travelTimeInBetween(i_loc_sub_route, i_act_cargo))  do  
					
					            SetElementAdd(s_calc_feasibleRoutes, ep_route, i_loc_sub_route + "_" + i_act_cargo);
					
					            p_loc_lastLoadArrivalTime(ep_route) | 
					                    p_loc_travelTimeLowerThanMinimum(i_loc_sub_route, i_act_cargo)
					            :=  p_def_minTimeWindow(i_act_cargo);
					
					            p_loc_lastLoadArrivalTime(ep_route) |
					                    p_loc_travelTimeInBetween(i_loc_sub_route, i_act_cargo)
					            :=  p_loc_travelTimeCargoes(ep_loc_lastCargoFromRoute(i_loc_sub_route), i_act_cargo) 
					                + p_loc_lastLoadArrivalTime(i_loc_sub_route);
					
					            ep_loc_lastCargoFromRoute(ep_route) := i_act_cargo;
					            ep_calc_vesselOnRoute(ep_route) := i_act_vessel;
					            p_loc_quantityOfCargos(ep_route) := p_loc_loopCount + 1;
					            p_calc_cargoesOnRoute(ep_route, i_act_cargo_aux) := p_calc_cargoesOnRoute(i_loc_sub_route, i_act_cargo_aux);
					            p_calc_cargoesOnRoute(ep_route, i_act_cargo) := p_loc_quantityOfCargos(ep_route);
					
					            !Loading and delivering time
					            p_calc_loadingTimeCargoRoute(i_act_cargo_aux, ep_route) 
					            :=  p_calc_loadingTimeCargoRoute(i_act_cargo_aux, i_loc_sub_route);
					
					            p_calc_loadingTimeCargoRoute(i_act_cargo, ep_route) |
					                    p_loc_travelTimeLowerThanMinimum(i_loc_sub_route, i_act_cargo)
					            :=  p_def_minTimeWindow(i_act_cargo);
					
					            p_calc_loadingTimeCargoRoute(i_act_cargo, ep_route) |
					                    p_loc_travelTimeInBetween(i_loc_sub_route, i_act_cargo)
					            :=  p_loc_travelTimeCargoes(ep_loc_lastCargoFromRoute(i_loc_sub_route), i_act_cargo) 
					                + p_loc_lastLoadArrivalTime(i_loc_sub_route);
					
					            !Add cargoes to route
					            sp_calc_cargoesOnRoute(ep_route) := sp_calc_cargoesOnRoute(i_loc_sub_route) + "," + i_act_cargo;
					
					            !Extra deliver arrival time
					            p_loc_lastDeliverArrivalTime(ep_route) 
					            :=  p_loc_lastLoadArrivalTime(ep_route) 
					                + p_distanceBetweenLocations(ep_loadingPortsCargo(i_act_cargo), ep_deliveringPortsCargo(i_act_cargo));
					
					            !Idle cost per route next cargoes
					            p_calc_totalRouteIdleCost(ep_route) | 
					                    p_loc_travelTimeLowerThanMinimum(i_loc_sub_route, i_act_cargo)
					            :=  p_calc_totalRouteIdleCost(i_loc_sub_route) 
					                +  p_idleCostLocation(ep_loadingPortsCargo(i_act_cargo)) 
					                * (p_def_minTimeWindow(i_act_cargo) 
					                    - (p_loc_travelTimeCargoes(ep_loc_lastCargoFromRoute(i_loc_sub_route), i_act_cargo) 
					                        + p_loc_lastLoadArrivalTime(i_loc_sub_route)));
					
					            !Cost for the other movements
					            p_calc_totalDaysTravelPerRoute(ep_route) 
					            :=  p_calc_totalDaysTravelPerRoute(i_loc_sub_route)
					                + p_distanceBetweenLocations(ep_deliveringPortsCargo(ep_loc_lastCargoFromRoute(ep_route)), ep_loadingPortsCargo(i_act_cargo))
					                + p_distanceBetweenLocations(ep_loadingPortsCargo(i_act_cargo), ep_deliveringPortsCargo(i_act_cargo));
					
					            !Cost for the other locations
					            if ep_deliveringPortsCargo(ep_loc_lastCargoFromRoute(i_loc_sub_route)) <> ep_loadingPortsCargo(i_act_cargo) then
					                p_calc_totalRouteLocationCost(ep_route) 
					                :=  p_calc_totalRouteLocationCost(i_loc_sub_route)
					                    + sum(i_act_ct_cargo, 
					                            p_locationCost(ep_loadingPortsCargo(i_act_cargo), i_act_ct_cargo) 
					                            + p_locationCost(ep_deliveringPortsCargo(i_act_cargo), i_act_ct_cargo));
					            else 
					                p_calc_totalRouteLocationCost(ep_route) 
					                :=  p_calc_totalRouteLocationCost(i_loc_sub_route)
					                    + sum(i_act_ct_cargo, p_locationCost(ep_deliveringPortsCargo(i_act_cargo), i_act_ct_cargo));                                
					            endif;                
					
					            !Cost for the other cargoes
					            p_calc_totalCargoFixedCost(ep_route) 
					            :=  p_calc_totalCargoFixedCost(i_loc_sub_route)
					                + sum(i_act_ct_cargo, p_cargoCost(i_act_cargo, i_act_ct_cargo));
					
					
					        endfor;
					
					        p_loc_loopCount += 1;
					
					    endrepeat;
					endfor;
					
					!Add the idle cost of a ship staying in the port of delevering
					for i_route do
					
					    if max(i_cargo, p_def_maxTimeWindow(i_cargo)) - p_loc_lastLoadArrivalTime(i_route) >= 0[day] then
					
					        p_calc_totalRouteIdleCost(i_route) 
					        +=  ((max(i_cargo, p_def_maxTimeWindow(i_cargo))- p_loc_lastLoadArrivalTime(i_route)))
					            * p_idleCostLocation(ep_DeliveringPortsCargo(ep_loc_lastCargoFromRoute(i_route)));
					
					    endif;
					endfor;
					
					!Activate solve button
					ui::sp_systemSecondaryActions(4,'state'):= 'active';
					
					!Changes to status bar
					ui::sp_systemStatusBar(2,'icon') := "aimms-checkmark-circle";
					ui::sp_systemStatusBar(2,'color') := "Green";
					ui::sp_systemStatusBar(2,'tooltip') := "The routes are succesfully generated.";
					ui::sp_systemStatusBar(3,'color') := "Orange";
					ui::sp_systemStatusBar(3,'icon') := "aimms-circle2";
					ui::sp_systemStatusBar(3,'tooltip') := "Data is ready, time to solve!";
					ui::sp_systemStatusBar(3,'state') := "active";
				}
				Set s_loc_subRoutes {
					SubsetOf: s_calc_feasibleRoutes;
					Index: i_loc_sub_route;
				}
				Parameter p_loc_loopCount;
				Parameter p_loc_travelTimeLowerThanMinimum {
					IndexDomain: (i_loc_sub_route,i_act_cargo);
				}
				Parameter p_loc_travelTimeInBetween {
					IndexDomain: (i_loc_sub_route,i_act_cargo);
				}
				Parameter p_loc_quantityOfCargos {
					IndexDomain: i_route;
				}
				Parameter p_loc_lastLoadArrivalTime {
					IndexDomain: i_route;
					Unit: day;
				}
				Parameter p_loc_lastDeliverArrivalTime {
					IndexDomain: i_route;
					Unit: day;
				}
				Parameter p_loc_travelTimeCargoes {
					IndexDomain: (i_cargo,i_cargo_aux) | (i_cargo<>i_cargo_aux);
					Unit: day;
				}
				ElementParameter ep_loc_lastCargoFromRoute {
					IndexDomain: i_route;
					Range: s_cargoes;
				}
			}
			Procedure pr_calculateRoutesAndCostBeforeSomeChangesFromGabi {
				Body: {
					!empty s_calc_feasibleRoutes;
					!empty p_calc_cargoesOnRoute;
					!
					!!Assumption: when a vessel is used, and the time horizon starts, 
					!!the vessel will always directly move to the loading port of the cargo.
					!
					!p_loc_travelTimeCargoes(i_cargo, i_cargo_aux) 
					!:=  p_distanceBetweenLocations(ep_loadingPortsCargo(i_cargo),ep_deliveringPortsCargo(i_cargo)) 
					!    + p_distanceBetweenLocations(ep_deliveringPortsCargo(i_cargo),ep_loadingPortsCargo(i_cargo_aux));
					!
					!for i_act_vessel do
					!
					!    p_loc_loopCount := 1;
					!
					!    for i_act_cargo do
					!
					!        SetElementAdd(s_calc_feasibleRoutes, ep_route, i_act_vessel + "_" + i_act_cargo);
					!        ep_loc_lastCargoFromRoute(ep_route) := i_act_cargo;
					!        ep_calc_vesselOnRoute(ep_route) := i_act_vessel;
					!        p_calc_cargoesOnRoute(ep_route, i_act_cargo) := 1;
					!        p_loc_quantityOfCargos(ep_route) := 1;
					!        sp_calc_cargoesOnRoute(ep_route) := i_act_cargo;
					!        
					!        !Cannot come earlier then arrival time
					!        p_loc_lastLoadArrivalTime(ep_route) |
					!                (p_distanceBetweenLocations(ep_originPortOfVessel(i_act_vessel), ep_loadingPortsCargo(i_act_cargo)) 
					!                <= p_def_minTimeWindow(i_act_cargo))
					!        :=  p_def_minTimeWindow(i_act_cargo);
					!
					!        p_loc_lastLoadArrivalTime(ep_route) |
					!                (p_def_minTimeWindow(i_act_cargo) 
					!                <= p_distanceBetweenLocations(ep_originPortOfVessel(i_act_vessel), ep_loadingPortsCargo(i_act_cargo)) 
					!                <= p_def_maxTimeWindow(i_act_cargo))
					!        :=  p_distanceBetweenLocations(ep_originPortOfVessel(i_act_vessel), ep_loadingPortsCargo(i_act_cargo));
					!
					!        
					!        !Loading and delivering time
					!        p_calc_loadingTimeCargoRoute(i_act_cargo, ep_route) |
					!                (p_distanceBetweenLocations(ep_originPortOfVessel(i_act_vessel), ep_loadingPortsCargo(i_act_cargo)) 
					!                <= p_def_minTimeWindow(i_act_cargo))
					!        :=  p_def_minTimeWindow(i_act_cargo);
					!
					!        p_calc_loadingTimeCargoRoute(i_act_cargo, ep_route) |
					!                (p_def_minTimeWindow(i_act_cargo) 
					!                <= p_distanceBetweenLocations(ep_originPortOfVessel(i_act_vessel), ep_loadingPortsCargo(i_act_cargo)) 
					!                <= p_def_maxTimeWindow(i_act_cargo))
					!        :=  p_distanceBetweenLocations(ep_originPortOfVessel(i_act_vessel), ep_LoadingPortsCargo(i_act_cargo));
					!
					!        
					!
					!        !Extra deliver arrival time NAO ENTENDI
					!        p_loc_lastDeliverArrivalTime(ep_route)
					!        :=  p_loc_lastLoadArrivalTime(ep_route) 
					!            + p_distanceBetweenLocations(ep_loadingPortsCargo(i_act_cargo), ep_deliveringPortsCargo(i_act_cargo));
					!
					!        !Idle cost per route first cargo
					!        p_calc_totalRouteIdleCost(ep_route) 
					!        :=  p_idleCostLocation(ep_loadingPortsCargo(i_act_cargo)) 
					!            * (p_def_minTimeWindow(i_act_cargo) 
					!                - p_distanceBetweenLocations(ep_originPortOfVessel(i_act_vessel), ep_loadingPortsCargo(i_act_cargo)));
					!
					!        !Cost for first movement
					!        p_calc_totalDaysTravelPerRoute(ep_route) 
					!        :=  p_distanceBetweenLocations(ep_originPortOfVessel(i_act_vessel), ep_loadingPortsCargo(i_act_cargo))
					!            + p_distanceBetweenLocations(ep_loadingPortsCargo(i_act_cargo), ep_deliveringPortsCargo(i_act_cargo));
					!
					!        !Cost for first location
					!        p_calc_totalRouteLocationCost(ep_route) 
					!        :=  sum(i_act_ct_cargo, 
					!                p_locationCost(ep_loadingPortsCargo(i_act_cargo), i_act_ct_cargo)
					!                + p_locationCost(ep_deliveringPortsCargo(i_act_cargo), i_act_ct_cargo));
					!
					!        !Cost for first cargo
					!        p_calc_CargoCostPerRoute(ep_route) := sum(i_act_ct_cargo, p_cargoCost(i_act_cargo, i_act_ct_cargo));
					!
					!    endfor;
					!
					!    repeat 
					!
					!        !Select all routes that are equal to the loop count and to the correct vessel
					!        s_loc_subRoutes 
					!        :=  {i_route | 
					!                    p_loc_quantityOfCargos(i_route) = p_loc_loopCount 
					!                    and ep_calc_vesselOnRoute(i_route) = i_act_vessel}; 
					!
					!        !Statement to break out of the loop
					!        if card(s_loc_subRoutes) = 0 then
					!            break;
					!        endif;
					!
					!        p_loc_travelTimeLowerThanMinimum(i_loc_sub_route, i_act_cargo)
					!        :=  1 $ (p_loc_travelTimeCargoes(ep_loc_lastCargoFromRoute(i_loc_sub_route), i_act_cargo) 
					!                + p_loc_lastLoadArrivalTime(i_loc_sub_route) 
					!                <= p_def_minTimeWindow(i_act_cargo));
					!
					!        p_loc_travelTimeInBetween(i_loc_sub_route, i_act_cargo) 
					!        :=  1 $ (p_def_minTimeWindow(i_act_cargo) 
					!                <= p_loc_travelTimeCargoes(ep_loc_lastCargoFromRoute(i_loc_sub_route), i_act_cargo) 
					!                + p_loc_lastLoadArrivalTime(i_loc_sub_route) 
					!                <= p_def_maxTimeWindow(i_act_cargo));
					!
					!        !Only cargoes that are not on the route yet
					!        for (i_loc_sub_route,i_act_cargo) | 
					!                    p_calc_cargoesOnRoute(i_loc_sub_route, i_act_cargo) = 0 
					!                    and (p_loc_travelTimeLowerThanMinimum(i_loc_sub_route, i_act_cargo) 
					!                        or p_loc_travelTimeInBetween(i_loc_sub_route, i_act_cargo))  do  
					!
					!            SetElementAdd(s_calc_feasibleRoutes, ep_route, i_loc_sub_route + "_" + i_act_cargo);
					!
					!            p_loc_lastLoadArrivalTime(ep_route) | 
					!                    p_loc_travelTimeLowerThanMinimum(i_loc_sub_route, i_act_cargo)
					!            :=  p_def_minTimeWindow(i_act_cargo);
					!
					!            p_loc_lastLoadArrivalTime(ep_route) |
					!                    p_loc_travelTimeInBetween(i_loc_sub_route, i_act_cargo)
					!            :=  p_loc_travelTimeCargoes(ep_loc_lastCargoFromRoute(i_loc_sub_route), i_act_cargo) 
					!                + p_loc_lastLoadArrivalTime(i_loc_sub_route);
					!
					!            ep_loc_lastCargoFromRoute(ep_route) := i_act_cargo;
					!            ep_calc_vesselOnRoute(ep_route) := i_act_vessel;
					!            p_loc_quantityOfCargos(ep_route) := p_loc_loopCount + 1;
					!            p_calc_cargoesOnRoute(ep_route, i_act_cargo_aux) := p_calc_cargoesOnRoute(i_loc_sub_route, i_act_cargo_aux);
					!            p_calc_cargoesOnRoute(ep_route, i_act_cargo) := p_loc_quantityOfCargos(ep_route);
					!
					!            !Loading and delivering time
					!            p_calc_loadingTimeCargoRoute(i_act_cargo_aux, ep_route) 
					!            :=  p_calc_loadingTimeCargoRoute(i_act_cargo_aux, i_loc_sub_route);
					!
					!            p_calc_loadingTimeCargoRoute(i_act_cargo, ep_route) |
					!                    p_loc_travelTimeLowerThanMinimum(i_loc_sub_route, i_act_cargo)
					!            :=  p_def_minTimeWindow(i_act_cargo);
					!
					!            p_calc_loadingTimeCargoRoute(i_act_cargo, ep_route) |
					!                    p_loc_travelTimeInBetween(i_loc_sub_route, i_act_cargo)
					!            :=  p_loc_travelTimeCargoes(ep_loc_lastCargoFromRoute(i_loc_sub_route), i_act_cargo) 
					!                + p_loc_lastLoadArrivalTime(i_loc_sub_route);
					!
					!            !Add cargoes to route
					!            sp_calc_cargoesOnRoute(ep_route) := sp_calc_cargoesOnRoute(i_loc_sub_route) + "," + i_act_cargo;
					!
					!            !Extra deliver arrival time
					!            p_loc_lastDeliverArrivalTime(ep_route) 
					!            :=  p_loc_lastLoadArrivalTime(ep_route) 
					!                + p_distanceBetweenLocations(ep_loadingPortsCargo(i_act_cargo), ep_deliveringPortsCargo(i_act_cargo));
					!
					!            !Idle cost per route next cargoes
					!            p_calc_totalRouteIdleCost(ep_route) | 
					!                    p_loc_travelTimeLowerThanMinimum(i_loc_sub_route, i_act_cargo)
					!            :=  p_calc_totalRouteIdleCost(i_loc_sub_route) 
					!                +  p_idleCostLocation(ep_loadingPortsCargo(i_act_cargo)) 
					!                * (p_def_minTimeWindow(i_act_cargo) 
					!                    - (p_loc_travelTimeCargoes(ep_loc_lastCargoFromRoute(i_loc_sub_route), i_act_cargo) 
					!                        + p_loc_lastLoadArrivalTime(i_loc_sub_route)));
					!
					!            !Cost for the other movements
					!            p_calc_totalDaysTravelPerRoute(ep_route) 
					!            :=  p_calc_totalDaysTravelPerRoute(i_loc_sub_route)
					!                + p_distanceBetweenLocations(ep_deliveringPortsCargo(ep_loc_lastCargoFromRoute(ep_route)), ep_loadingPortsCargo(i_act_cargo))
					!                + p_distanceBetweenLocations(ep_loadingPortsCargo(i_act_cargo), ep_deliveringPortsCargo(i_act_cargo));
					!
					!            !Cost for the other locations
					!            if ep_deliveringPortsCargo(ep_loc_lastCargoFromRoute(i_loc_sub_route)) <> ep_loadingPortsCargo(i_act_cargo) then
					!                p_calc_totalRouteLocationCost(ep_route) 
					!                :=  p_calc_totalRouteLocationCost(i_loc_sub_route)
					!                    + sum(i_act_ct_cargo, 
					!                            p_locationCost(ep_loadingPortsCargo(i_act_cargo), i_act_ct_cargo) 
					!                            + p_locationCost(ep_deliveringPortsCargo(i_act_cargo), i_act_ct_cargo));
					!            else 
					!                p_calc_totalRouteLocationCost(ep_route) 
					!                :=  p_calc_totalRouteLocationCost(i_loc_sub_route)
					!                    + sum(i_act_ct_cargo, p_locationCost(ep_deliveringPortsCargo(i_act_cargo), i_act_ct_cargo));                                
					!            endif;                
					!
					!            !Cost for the other cargoes
					!            p_calc_CargoCostPerRoute(ep_route) 
					!            :=  p_calc_CargoCostPerRoute(i_loc_sub_route)
					!                + sum(i_act_ct_cargo, p_cargoCost(i_act_cargo, i_act_ct_cargo));
					!
					!
					!        endfor;
					!
					!        p_loc_loopCount += 1;
					!
					!    endrepeat;
					!endfor;
					!
					!!Add the idle cost of a ship staying in the port of delevering
					!for i_route do
					!
					!    if max(i_cargo, p_def_maxTimeWindow(i_cargo)) - p_loc_lastLoadArrivalTime(i_route) >= 0[day] then
					!
					!        p_calc_totalRouteIdleCost(i_route) 
					!        +=  ((max(i_cargo, p_def_maxTimeWindow(i_cargo))- p_loc_lastLoadArrivalTime(i_route)))
					!            * p_idleCostLocation(ep_DeliveringPortsCargo(ep_loc_lastCargoFromRoute(i_route)));
					!
					!    endif;
					!endfor;
					!
					!!Activate solve button
					!ui::sp_systemSecondaryActions(4,'state'):= 'active';
					!
					!!Changes to status bar
					!ui::sp_systemStatusBar(2,'icon') := "aimms-checkmark-circle";
					!ui::sp_systemStatusBar(2,'color') := "Green";
					!ui::sp_systemStatusBar(2,'tooltip') := "The routes are succesfully generated.";
					!ui::sp_systemStatusBar(3,'color') := "Orange";
					!ui::sp_systemStatusBar(3,'icon') := "aimms-circle2";
					!ui::sp_systemStatusBar(3,'tooltip') := "Data is ready, time to solve!";
					!ui::sp_systemStatusBar(3,'state') := "active";
					!
				}
			}
			Procedure pr_gabiWasTryingToRedoTheRoutes {
				Body: {
					empty s_calc_feasibleRoutes;
					empty p_calc_cargoesOnRoute;
					
					p_cargoCardinality := card(i_act_cargo);
					
					for i_act_vessel do
					    p_loc_counter := 1;
					    while p_loc_counter <= p_cargoCardinality do
					
					    for i_act_cargo do
					
					        SetElementAdd(s_calc_feasibleRoutes, ep_route, i_act_vessel + "_" + i_act_cargo);
					
					        s_loc_subCargos := s_def_activeCargoes - i_act_cargo;
					
					        for test do
					            SetElementAdd(s_calc_feasibleRoutes, ep_loc_route, ep_route + "_" + test);    
					        endfor;
					
					        ep_route := ep_loc_route;
					
					    endfor;
					
					    p_loc_counter += 1;
					
					    endwhile;
					endfor;
				}
			}
			Parameter p_calc_totalCargoDailyCost {
				IndexDomain: i_route;
				Unit: $;
			}
			Parameter p_calc_totalCargoFixedCost {
				IndexDomain: i_route;
				Unit: $;
			}
			Parameter p_calc_totalVesselDailyCost {
				IndexDomain: i_route;
				Unit: $;
			}
			Parameter p_calc_totalVesselFixedCost {
				IndexDomain: i_route;
				Unit: $;
			}
			Parameter p_calc_totalLocationFixedCost {
				IndexDomain: i_route;
				Unit: $;
			}
			Parameter bp_calc_routeLocations {
				IndexDomain: (i_route,i_loc);
			}
			Parameter p_cargoCardinality;
			Parameter p_loc_counter;
			Set s_loc_subCargos {
				SubsetOf: s_def_activeCargoes;
				Index: test;
			}
			ElementParameter ep_loc_route {
				Range: s_calc_feasibleRoutes;
			}
		}
	}
	Section Integration {
		Procedure pr_importExcel {
			Body: {
				dex::GenerateDatasetMappings;
				
				!Delete old data
				empty Cargoes, Vessels, Cost_Types, Locations, Routes;
				
				!Importeren van de data
				dex::AddMapping(
				    mappingName : "ImportData", 
				    mappingFile : "./Mappings/Generated/Import-Excel.xml");
				
				dex::ReadFromFile(
				    dataFile : "data\\DataForImport_test_v2.xlsx", !Uiteindelijke variant DataForImport.xlsx
				    mappingName : "ImportData");
				
				!Activate all master data
				bp_activeCargoes(i_cargo):= 1;
				bp_activeVessels(i_vessel) := 1;
				bp_activeLocations(i_loc) := 1;
				p_AllocatedCargoes(i_act_cargo) :=1;
				
				!Activate generating routes
				ui::sp_systemSecondaryActions(3,'state'):= 'active';
				
				!Changes to status bar
				ui::sp_systemStatusBar(1,'icon') := "aimms-checkmark-circle";
				ui::sp_systemStatusBar(1,'color') := "Green";
				ui::sp_systemStatusBar(1,'tooltip') := "Data is succesfully imported.";
				ui::sp_systemStatusBar(2,'color') := "Orange";
				ui::sp_systemStatusBar(2,'icon'):= "aimms-circle2";
				ui::sp_systemStatusBar(2,'tooltip') := "Application ready to generate routes.";
				ui::sp_systemStatusBar(2,'state') := "active";
				ui::sp_systemStatusBar(3,'color') := "red";
				ui::sp_systemStatusBar(3,'icon') := "aimms-cancel-circle2";
				ui::sp_systemStatusBar(3,'tooltip') := "Model not ready to be solved.";
				ui::sp_systemStatusBar(3,'state') := 'inactive';
				
				!Open Overview dataset
				ui::sp_systemWorkflowFoldingStates(1, 4, 'openclose') := "open";
			}
		}
		Procedure pr_exportExcel {
			Body: {
				dex::AddMapping(
				    mappingName : "Import",
				    mappingFile : "./Mappings/Generated/Import-Excel.xml");
				
				dex::WriteToFile(
				    dataFile : "data\\FormatDataScheduling.xlsx",
				    mappingName : "Import");
			}
		}
		Procedure pr_emptyData {
			Body: {
				!@TODO
			}
		}
	}
	Section WebUIVessel {
		Procedure pr_LegendRouteViz {
			Body: {
				for i_CargLocLoadRoute do
				    setelementadd(s_SortPortsRouteVis,ep_SortPortsRouteVis,sp_PortsVisualisationPageAnnotation(i_CargLocLoadRoute));
				endfor;
				
				for i_CargLocDelRoute do   
				    setelementadd(s_SortPortsRouteVis,ep_SortPortsRouteVis,sp_PortsVisualisationPageAnnotation(i_CargLocDelRoute));   
				endfor;
				
				for i_VesselPortOrigin do
				    setelementadd(s_SortPortsRouteVis,ep_SortPortsRouteVis,sp_PortsVisualisationPageAnnotation(i_VesselPortOrigin)); 
				endfor;
			}
		}
		Procedure pr_LegendCargoViz {
			Body: {
				for i_locLoad do
				    setelementadd(s_SortOfPortsCargo,ep_SortOfPortsCargo,ui::sp_def_cargoesMapAnnotation(i_locLoad));
				endfor;
				
				for i_locDeliv do   
				    setelementadd(s_SortOfPortsCargo,ep_SortOfPortsCargo,ui::sp_def_cargoesMapAnnotation(i_locDeliv));   
				endfor;
			}
		}
		DeclarationSection Declaration_Mapping_CargoData {
			Set s_SortOfPortsCargo {
				Index: i_SortOfPort;
				Parameter: ep_SortOfPortsCargo;
				Definition: pr_LegendCargoViz;
			}
			Set s_SelectedCargoesInMap {
				SubsetOf: s_def_activeCargoes;
				Index: i_selectedCargo;
				Definition: {
					{i_act_cargo | p_AllocatedCargoes(i_act_cargo)}
				}
			}
		}
		DeclarationSection Declaration_Mapping_Visualisation_Route {
			Set s_CargoesOnSelectedRoutes {
				SubsetOf: s_cargoes;
				Index: i_SelectedCargoOnRoute;
				Definition: {
					{i_act_cargo|exists(mm::i_allcRoute| p_calc_cargoesOnRoute(mm::i_allcRoute, i_act_cargo))}
				}
				Comment: "{i_ActiveCargo|exists(i_selectedRoute|p_CargoesOnRouteBin(i_selectedRoute, i_ActiveCargo)}";
			}
			Set s_VesselOnSelectedRoutes {
				SubsetOf: s_vessels;
				Index: i_ActiveVesselUsed;
				Definition: {
					{i_act_vessel | exists(mm::i_allcRoute|ep_calc_vesselOnRoute(mm::i_allcRoute)=i_act_vessel)}
				}
			}
			Set s_SubsetCargoLoadingRoutePorts {
				SubsetOf: s_locations;
				Index: i_CargLocLoadRoute;
				Definition: {
					{i_Loc|exists(i_SelectedCargoOnRoute | i_Loc = ep_LoadingPortsCargo(i_SelectedCargoOnRoute))}
				}
			}
			Set s_SubsetCargoDeliveringRoutePorts {
				SubsetOf: s_locations;
				Index: i_CargLocDelRoute;
				Definition: {
					{i_Loc|exists(i_SelectedCargoOnRoute | i_Loc = ep_DeliveringPortsCargo(i_SelectedCargoOnRoute))}
				}
			}
			Set s_SubsetVesselLoadingPorts {
				SubsetOf: s_locations;
				Index: i_VesselPortOrigin;
				Definition: {
					!{i_Loc|exists(i_ActiveVessel | i_Loc = ep_LoadingPortsVessel(i_ActiveVessel)| v_IdleVessel(i_ActiveVessel)<1)}
					{i_Loc|exists(i_ActiveVesselUsed | i_Loc = ep_originPortOfVessel(i_ActiveVesselUsed))}
				}
			}
			StringParameter sp_PortsVisualisationPageAnnotation {
				IndexDomain: i_Loc;
				Definition: {
					if (i_Loc in s_SubsetCargoLoadingRoutePorts) and (i_loc in s_SubsetCargoDeliveringRoutePorts) and 
					    (i_Loc in s_SubsetVesselLoadingPorts) then
					    "AllThreePorts"
					elseif (i_Loc in s_SubsetVesselLoadingPorts) and (i_loc in s_SubsetCargoDeliveringRoutePorts) then
					    "VesAndDelPort"
					elseif (i_Loc in s_SubsetVesselLoadingPorts) and (i_loc in s_SubsetCargoLoadingRoutePorts) then
					    "VesAndLoadPort"
					elseif (i_Loc in s_SubsetVesselLoadingPorts) and (i_loc in s_SubsetCargoDeliveringRoutePorts) then
					    "LoadAndDelPort"    
					elseif i_Loc in s_SubsetVesselLoadingPorts then
					    "VesPort"
					elseif i_Loc in s_def_loadingPorts then
					    "LoadPort"
					else
					    "DelPort"
					endif;
				}
			}
			Set s_SortPortsRouteVis {
				Index: i_SortRouteVis;
				Parameter: ep_SortPortsRouteVis;
				Definition: pr_LegendRouteViz;
			}
			Parameter p_SizeRoutesLocation {
				IndexDomain: i_Loc;
				Definition: 1;
				webui::AnnotationsIdentifier: sp_PortsVisualisationPageAnnotation(i_Loc);
			}
		}
		DeclarationSection Declaration_GanttChart {
			Parameter p_DurationCargoOnRoute {
				IndexDomain: (i_act_cargo,i_route);
				Unit: day;
				Definition: (p_def_deleveringTimeCargoRoute(i_act_cargo, i_route)-p_calc_loadingTimeCargoRoute(i_act_cargo, i_route))*24;
			}
			Parameter p_LoadingTimeCargoRouteInHours {
				IndexDomain: (i_act_cargo,i_route);
				Unit: day;
				Definition: p_calc_loadingTimeCargoRoute(i_act_cargo, i_route)*24;
			}
		}
		Section Arcs {
			Procedure pr_CalculateAllArcs {
				Body: {
					empty p_mapArcPerCargo, p_mapArcPerCargoConsideringPickupDropoff,p_FromBerthToCargoTest,p_FromBerthToCargo,p_MapArcPerCargoLocations,sp_RouteInformation;
					sp_RouteInformation(i_Loc,i_loc_from):=FormatString("%e <br>to<br>%s",i_Loc,i_loc_from);
					
					for mm::i_allcRoute do
					
					    !Calculate location from berth to the location of the loading of the first cargo
					    p_FromBerthToCargoTest(ep_originPortOfVessel(ep_calc_vesselOnRoute(mm::i_allcRoute)),ep_LoadingPortsCargo(first(i_act_cargo|p_calc_cargoesOnRoute(mm::i_allcRoute,i_act_cargo)=1))):=1;
					    mm::ep_allcRoute := mm::i_allcRoute;
					    s_loc_currentCargos := {i_act_cargo | p_calc_cargoesOnRoute(mm::ep_allcRoute, i_act_cargo)};
					    sp_RouteInformation(ep_originPortOfVessel(ep_calc_vesselOnRoute(mm::i_allcRoute)),ep_LoadingPortsCargo(first(i_act_cargo|p_calc_cargoesOnRoute(mm::i_allcRoute,i_act_cargo)=1)))+="<br>Picking up cargo: "+first(i_act_cargo|p_calc_cargoesOnRoute(mm::i_allcRoute,i_act_cargo)=1);
					
					    for i_loc_cargo | p_calc_cargoesOnRoute(mm::i_allcRoute, i_loc_cargo) do 
					    	!Calculate location of the loading and delivering of the cargo
					        p_MapArcPerCargoLocations(ep_LoadingPortsCargo(i_loc_cargo), ep_DeliveringPortsCargo(i_loc_cargo)) := 1;
						sp_RouteInformation(ep_LoadingPortsCargo(i_loc_cargo), ep_DeliveringPortsCargo(i_loc_cargo))+="<br>Deliver cargo: "+i_loc_cargo;
					
						!Calculate the location from delivering to the loading point of the new cargo
					        for i_loc_cargo1 | 
					                p_calc_cargoesOnRoute(mm::i_allcRoute, i_loc_cargo) < p_calc_cargoesOnRoute(mm::i_allcRoute, i_loc_cargo1) 
					                and i_loc_cargo1 <> i_loc_cargo do
					
					            p_mapArcPerCargo(mm::i_allcRoute, i_loc_cargo, i_loc_cargo1) := 1;
					
					            if ep_DeliveringPortsCargo(i_loc_cargo) = ep_LoadingPortsCargo(i_loc_cargo1) then
					                p_MapArcPerCargoLocations(ep_LoadingPortsCargo(i_loc_cargo1), ep_DeliveringPortsCargo(i_loc_cargo1)) := 1;
					                p_loc_aux := 1;
					            else
					                p_MapArcPerCargoLocations(ep_DeliveringPortsCargo(i_loc_cargo), ep_LoadingPortsCargo(i_loc_cargo1)) := 1;
					                p_MapArcPerCargoLocations(ep_LoadingPortsCargo(i_loc_cargo1), ep_DeliveringPortsCargo(i_loc_cargo1)) := 1;
					
					                sp_RouteInformation(ep_DeliveringPortsCargo(i_loc_cargo), ep_LoadingPortsCargo(i_loc_cargo1))+="<br>Picking up cargo: "+i_loc_cargo1;
					
					            endif;
					
					            break;
					        endfor;
					    endfor;
					endfor;
				}
				Set s_loc_currentCargos {
					SubsetOf: s_cargoes;
					Index: i_loc_cargo, i_loc_cargo1;
					OrderBy: p_calc_cargoesOnRoute(mm::ep_allcRoute, i_cargo);
				}
				Parameter p_loc_aux;
			}
			DeclarationSection Declaration_Arcs {
				StringParameter sp_CargoLoadingtoCargoDelivery {
					IndexDomain: (ui::i_loc_usag,ui::i_loc_usag2);
					Definition: {
						FormatString("%e <br>to<br>%s <br> %n Days",ui::i_loc_usag,ui::i_loc_usag2,ui::p_def_deliveringToLoadingPorts(ui::i_loc_usag,ui::i_loc_usag2));
					}
				}
				StringParameter sp_RouteInformation {
					IndexDomain: (i_loc,i_loc_from);
				}
				ElementParameter ep_AllocatedRoute {
					IndexDomain: mm::i_allcRoute;
					Range: mm::s_def_allocatedRoutes;
				}
				Parameter p_AllocatedCargoes {
					IndexDomain: i_act_cargo;
					Range: binary;
				}
				Parameter p_FromToDestination {
					IndexDomain: i_route;
				}
				Parameter p_FromBerthToCargo {
					IndexDomain: (mm::i_allcRoute,i_loc,i_loc_from);
				}
				Parameter p_FromBerthToCargoTest {
					IndexDomain: (i_Loc,i_loc_from);
					webui::TooltipIdentifier: sp_RouteInformation( i_Loc, i_loc_from );
				}
				Parameter p_MapArcPerCargoLocations {
					IndexDomain: (i_Loc,i_loc_from);
					webui::TooltipIdentifier: sp_RouteInformation;
				}
				Parameter p_mapArcPerCargo {
					IndexDomain: (mm::i_allcRoute,i_Cargo,i_cargo_aux);
					Range: binary;
				}
				Parameter p_mapArcPerCargoConsideringPickupDropoff {
					IndexDomain: (mm::i_allcRoute,i_Loc,i_loc_from);
					Range: binary;
				}
			}
		}
	}
	Section app_start_and_stop {
		Procedure MainInitialization {
			Body: {
				ProfilerStart();
				ep_startHorizonDate := StringToElement(cal_days, CurrentToString("%c%y-%m-%d"), 0);
			}
			Comment: "Add initialization statements here that do NOT require any library being initialized already.";
		}
		Procedure PostMainInitialization {
			Comment: {
				"Add initialization statements here that require that the libraries are already initialized properly,
				or add statements that require the Data Management module to be initialized."
			}
		}
		Procedure pr_start;
		Procedure pr_goodbye {
			Body: {
				if ProjectDeveloperMode() then
					ExitAimms();
				else
					pro::sessionmanager::FinishSession();
				endif ;
			}
		}
		Procedure PreMainTermination {
			Body: {
				return DataManagementExit();
			}
			Comment: {
				"Add termination statements here that require all libraries to be still alive.
				Return 1 if you allow the termination sequence to continue.
				Return 0 if you want to cancel the termination sequence."
			}
		}
		Procedure MainTermination {
			Body: {
				return 1;
			}
			Comment: {
				"Add termination statements here that do not require all libraries to be still alive.
				Return 1 to allow the termination sequence to continue.
				Return 0 if you want to cancel the termination sequence.
				It is recommended to only use the procedure PreMainTermination to cancel the termination sequence and let this procedure always return 1."
			}
		}
	}
	Section app_test {
		Procedure MainExecution {
			Body: {
				solve mm::mp_vesselScheduling;
				
				ui::sp_systemWorkFlowSteps(1,8,'workflowPageState') := "active";
				ui::sp_systemWorkFlowSteps(1,9,'workflowPageState') := "active";
				
				!Changes statusbar
				ui::sp_systemStatusBar(3,'icon') := "aimms-checkmark-circle";
				ui::sp_systemStatusBar(3,'color') := "Green";
				ui::sp_systemStatusBar(3,'tooltip') := "The model has been solved.";
				
				!Post Execution
				mm::pr_post_vesselResults;
				mm::pr_post_cargoResults;
				
				!Get the arcs
				pr_CalculateAllArcs;
			}
		}
	}
	Section Leverage_DEX;
	Section Leverage_WebUI;
}
