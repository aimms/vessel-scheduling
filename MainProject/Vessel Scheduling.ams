## ams_version=1.0

Model Main_Vessel_Schedule {
	Comment: {
		"Vessel Scheduling Application structure:
		
		The Main model focuses mostly on the data model, in section Data Model.
		
		Major steps:
		- Reading input
		  - pr_importExcel
		    Notes:
		    - Uses AimmsDEX to read Excel with annotations of identifiers.
		    - At the end, settings of Workflow and Statusbar are adapted.
		- Computations
		  - Generating Routes
		  - Costing of generated routes
		  - Optimization
		- Reporting
		
		MM: Mathematical modeling - Most computational stuff is in library MathematicalModel with prefix mm.
		
		
		UI: Most UI stuff is in library UserInterface with prefix ui.
		- status bar
		- workflow
		- pages
		  - Welcome
		    - Welcome
		    - Problem statement
		  - Data
		    - Locations
		    - Cargoes
		    - Vessel
		  - Computations
		  - Reporting"
	}
	Section Data_Model {
		Section Quantities_and_Units {
			Comment: {
				"This section contains all the units and quantities that are added automatically by AIMMS.
				It is recommended to declare all your quantities here."
			}
			Quantity SI_Time_Duration {
				BaseUnit: s;
				Conversions: {
					day->s : #-># * 86400,
					minute->s : #-># * 60,
					century->s : #-># * 3153600000,
					year->s : #-># * 31536000,
					month->s : #-># * 2628000,
					week->s : #-># * 604800,
					hour->s : #-># * 3600,
					tick->s : #-># / 100,
					second->s : #->#
				}
				Comment: "Expresses the value for the duration of periods.";
			}
			Quantity Q_Currency {
				BaseUnit: $;
			}
			Quantity SI_Length {
				BaseUnit: m;
				Conversions: km->m : #->1000*#;
				Comment: "Expresses the value of a distance.";
			}
		}
		Section Calendars {
			StringParameter sp_today;
			Calendar cal_days {
				Index: i_day;
				Unit: day;
				BeginDate: sp_def_beginDate;
				EndDate: sp_def_endDate;
				TimeslotFormat: "%c%y-%m-%d";
			}
			ElementParameter ep_startHorizonDate {
				Range: cal_days;
				Comment: "Start of modeling horizon.";
				dex::ColumnName: StartDate;
				dex::Dataset: Import;
				dex::TableName: Horizon;
			}
			ElementParameter ep_def_finishHorizonDate {
				Range: cal_days;
				Definition: max( i_act_cargo, ep_maxTimeWindow( i_act_cargo ) + ( p_def_deliveryTimeCargo(i_act_cargo) / 1[day] ) );
				Comment: "Last pickup time of cargos";
			}
			Parameter p_def_noDaysSchedule {
				Unit: day;
				Definition: {
					if ep_def_finishHorizonDate and ep_startHorizonDate then
						( ep_def_finishHorizonDate - ep_startHorizonDate ) + 1[day]
					else
						60[day]
					endif ;
				}
			}
			StringParameter sp_def_beginDate {
				Definition: "2000-01-01";
			}
			StringParameter sp_def_endDate {
				Definition: "2099-12-31";
			}
			Procedure pr_initCalendar {
				Body: {
					sp_today := CurrentToString("%c%y-%m-%d");
					ep_startHorizonDate := StringToElement(cal_days, sp_today, 0);
				}
			}
		}
		Section Cargoes {
			Set s_cargoes {
				Index: i_cargo_aux;
				Parameter: ep_cargo;
			}
			Index i_cargo {
				Range: s_cargoes;
				dex::ColumnName: Cargo;
			}
			Set s_def_activeCargoes {
				SubsetOf: s_cargoes;
				Index: i_act_cargo, i_act_cargo_aux;
				Definition: {
					{i_cargo | bp_activeCargoes(i_cargo)}
				}
			}
			Parameter bp_activeCargoes {
				IndexDomain: i_cargo;
				Range: binary;
				InitialData: 1;
			}
			Parameter p_spotCostVessel {
				IndexDomain: i_cargo;
				Unit: $;
				dex::ColumnName: Spot Cost;
				dex::Dataset: Import;
				dex::TableName: CargoData;
				webui::AnnotationsIdentifier: ui::sp_def_focusedCargo(i_cargo);
			}
			ElementParameter ep_minTimeWindow {
				IndexDomain: i_cargo;
				Range: cal_days;
				dex::ColumnName: Minimum Loading Time;
				dex::Dataset: Import;
				dex::TableName: CargoData;
				webui::AnnotationsIdentifier: ui::sp_def_focusedCargo(i_cargo);
			}
			ElementParameter ep_maxTimeWindow {
				IndexDomain: i_cargo;
				Range: cal_days;
				dex::ColumnName: Maximum Loading Time;
				dex::Dataset: Import;
				dex::TableName: CargoData;
				webui::AnnotationsIdentifier: ui::sp_def_focusedCargo(i_cargo);
			}
			ElementParameter ep_loadingPortsCargo {
				IndexDomain: i_cargo;
				Range: s_locations;
				dex::ColumnName: Loading Port;
				dex::Dataset: Import;
				dex::TableName: CargoData;
				webui::AnnotationsIdentifier: ui::sp_def_focusedCargo(i_cargo);
			}
			ElementParameter ep_deliveringPortsCargo {
				IndexDomain: i_cargo;
				Range: s_locations;
				dex::ColumnName: Delevering Port;
				dex::Dataset: Import;
				dex::TableName: CargoData;
				webui::AnnotationsIdentifier: ui::sp_def_focusedCargo(i_cargo);
			}
			Parameter p_def_deliveryTimeCargo {
				IndexDomain: i_cargo;
				Unit: day;
				Definition: {
					p_def_distanceBetweenLocations(
						ep_loadingPortsCargo(i_cargo), 
						ep_deliveringPortsCargo(i_cargo))
				}
			}
			Parameter p_cargoCost {
				IndexDomain: (i_cargo);
				Range: free;
				Unit: $;
				dex::ColumnName: Fixed Cost;
				dex::Dataset: Import;
				dex::TableName: CargoData;
				webui::AnnotationsIdentifier: ui::sp_def_focusedCargo(i_cargo);
			}
			Set s_def_loadingPorts {
				SubsetOf: s_locations;
				Index: i_locLoad;
				Definition: {
					{i_loc | exists(i_cargo | i_loc = ep_loadingPortsCargo(i_cargo))}
				}
			}
			Set s_def_deleveringPorts {
				SubsetOf: s_locations;
				Index: i_locDeliv;
				Definition: {
					{i_loc | exists(i_cargo | i_loc = ep_deliveringPortsCargo(i_cargo))}
				}
			}
			Set s_def_vesselOriginPorts {
				SubsetOf: s_locations;
				Index: i_locVess;
				Definition: {
					{i_loc | exists(i_act_vessel | i_loc = ep_originPortOfVessel(i_act_vessel))}
				}
			}
			Parameter p_def_minTimeWindow {
				IndexDomain: i_cargo;
				Unit: day;
				Definition: StringToMoment("%c%y-%m-%d", [day], ep_startHorizonDate, ep_minTimeWindow(i_cargo));
			}
			Parameter p_def_maxTimeWindow {
				IndexDomain: i_cargo;
				Unit: day;
				Definition: StringToMoment("%c%y-%m-%d", [day], ep_startHorizonDate, ep_maxTimeWindow(i_cargo));
			}
			Parameter p_def_maxDeliveryDate {
				IndexDomain: i_cargo;
				Unit: day;
				Definition: {
					p_def_maxTimeWindow(i_cargo) +
					p_def_deliveryTimeCargo(i_cargo)
				}
			}
		}
		Section Vessels {
			Set s_vessels {
				Parameter: ep_vessel;
			}
			Index i_vessel {
				Range: s_vessels;
				dex::ColumnName: Vessel;
			}
			Set s_def_activeVessels {
				SubsetOf: s_vessels;
				Index: i_act_vessel;
				Definition: {
					{i_vessel | bp_activeVessels(i_vessel)}
				}
			}
			Parameter bp_activeVessels {
				IndexDomain: i_vessel;
				Range: binary;
				InitialData: 1;
			}
			ElementParameter ep_originPortOfVessel {
				IndexDomain: i_vessel;
				Range: s_locations;
				dex::ColumnName: Port of Origin;
				dex::Dataset: Import;
				dex::TableName: VesselData;
			}
			Parameter p_sailingCost {
				IndexDomain: (i_vessel);
				Unit: $/day;
				Comment: {
					"! Fuel usage per day is 63000 gallons = 238000 liter -> 238000/100000 * â‚¬601 = 1433"
				}
				dex::ColumnName: Sailing Cost;
				dex::Dataset: Import;
				dex::TableName: VesselData;
			}
			Parameter p_def_idleCostVesselNotUsed {
				IndexDomain: i_vessel;
				Unit: $;
				Definition: {
					p_def_noDaysSchedule * 
					p_idleCostLocation( ep_originPortOfVessel( i_vessel ) )
				}
			}
			Set s_def_vesselActivities {
				Index: i_vesselActivities;
				Definition: {
					data { 
						idleNothingToDo,  ! Waiting; no more cargos to be handled for this route.
						idleWaitForCargo, ! Waiting in a port for a Cargo to become available.
						sailingPickup,    ! Sailing towards a pickup point.
						sailingDelivery   ! Sailing towards a delivery point.
					}
				}
				webui::ElementTextIdentifier: sp_vesselActivityPresentation;
			}
			ElementParameter ep_def_vesselIdleWaitCargo {
				Range: s_def_vesselActivities;
				Definition: 'idleWaitForCargo';
			}
			ElementParameter ep_def_vesselIdleRetired {
				Range: s_def_vesselActivities;
				Definition: 'idleNothingToDo';
			}
			ElementParameter ep_def_vesselSailingPickup {
				Range: s_def_vesselActivities;
				Definition: 'sailingPickup';
			}
			ElementParameter ep_def_vesselSailingDelivery {
				Range: s_def_vesselActivities;
				Definition: 'sailingDelivery';
			}
			StringParameter sp_vesselActivityPresentation {
				IndexDomain: i_vesselActivities;
				Definition: {
					data { 
						idleNothingToDo  : "Idle - Waiting for end",  ! Waiting; no more cargos to be handled for this route.
						idleWaitForCargo : "Idle - Waiting for cargo", ! Waiting in a port for a Cargo to become available.
						sailingPickup    : "Sailing to pickup point",    ! Sailing towards a pickup point.
						sailingDelivery  : "Sailing to delivery point"  ! Sailing towards a delivery point.
					}
				}
			}
		}
		Section Locations {
			Set s_locations {
				Parameter: ep_location;
			}
			Index i_loc {
				Range: s_locations;
				dex::ColumnName: Location;
			}
			Index i_loc_from {
				Range: s_locations;
				dex::ColumnName: Location (From);
			}
			Index i_loc_to {
				Range: s_locations;
				dex::ColumnName: Location (To);
			}
			Set s_def_activeLocations {
				SubsetOf: s_locations;
				Index: i_act_loc;
				Definition: {
					{i_loc | bp_activeLocations(i_loc)}
				}
			}
			Parameter bp_activeLocations {
				IndexDomain: i_loc;
				Range: binary;
				InitialData: 1;
			}
			Parameter p_latitude {
				IndexDomain: i_loc;
				dex::ColumnName: Latitude;
				dex::Dataset: Import;
				dex::TableName: LocationData;
			}
			Parameter p_longitude {
				IndexDomain: i_loc;
				dex::ColumnName: Longitude;
				dex::Dataset: Import;
				dex::TableName: LocationData;
			}
			Parameter p_idleCostLocation {
				IndexDomain: i_loc;
				Unit: $/day;
				dex::ColumnName: Idle Cost;
				dex::Dataset: Import;
				dex::TableName: LocationData;
				webui::AnnotationsIdentifier: ui::sp_def_focusedLocationFrom;
			}
			Parameter p_adminCostAtLocation {
				IndexDomain: (i_loc);
				Unit: $;
				dex::ColumnName: Admin Cost;
				dex::Dataset: Import;
				dex::TableName: LocationData;
				webui::AnnotationsIdentifier: ui::sp_def_focusedLocationFrom;
			}
			Parameter p_loadingCostAtLocation {
				IndexDomain: (i_loc);
				Unit: $;
				dex::ColumnName: Loading Cost;
				dex::Dataset: Import;
				dex::TableName: LocationData;
				webui::AnnotationsIdentifier: ui::sp_def_focusedLocationFrom;
			}
			Parameter p_vesselVelocity {
				Unit: km/hour;
				InitialData: 37.04;
				Comment: "20 knots";
			}
			Parameter p_def_harvesineDistanceBetweenLocations {
				IndexDomain: (i_loc_from,i_loc_to)| i_loc_from <> i_loc_to;
				Unit: day;
				Definition: {
					((6371.0[km])
					    * arccos(
					        cos(radians(90 - P_latitude(i_loc_from)))
					        * cos(radians(90 - P_latitude(i_loc_to)))
					        +
					        sin(radians(90 - P_latitude(i_loc_from)))
					        * sin(radians(90 - P_latitude(i_loc_to)))
					        * cos(radians(p_longitude(i_loc_from) - p_longitude(i_loc_to)))))
					/$ p_vesselVelocity
				}
			}
			Parameter p_def_distanceBetweenLocations {
				IndexDomain: (i_loc_from, i_loc_to);
				Unit: day;
				Definition: round(p_def_harvesineDistanceBetweenLocations(i_loc_from, i_loc_to),0);
			}
		}
		Section Routes {
			Set s_calc_feasibleRoutes {
				Index: i_route;
				Parameter: ep_route;
			}
			Set s_calc_legs {
				SubsetOf: Integers;
				Index: i_leg, i_leg_aux;
				Property: ElementsAreLabels;
				Definition: {
					{ 1 .. 1000 }
				}
			}
			Set s_calc_usedRoutes {
				SubsetOf: s_calc_feasibleRoutes;
				Index: i_used_route;
				Comment: "The routes in the solution of the last solved mm::mp_vesselScheduling.";
			}
			Set s_calc_cargosHandled {
				IndexDomain: i_route;
				SubsetOf: s_cargoes;
				OrderBy: user;
			}
			Set s_temp_routeWorkingList {
				SubsetOf: s_calc_feasibleRoutes;
				Index: i_workRoute;
				Parameter: ep_workRoute;
				OrderBy: user;
				Comment: {
					"This set of route functions as a FIFO list;
					new routes are appended to the end, and processed from the
					beginning."
				}
			}
			ElementParameter ep_temp_lastLocation {
				IndexDomain: i_route;
				Range: s_locations;
			}
			ElementParameter ep_temp_nextSailingDay {
				IndexDomain: i_route;
				Range: cal_days;
			}
			ElementParameter ep_calc_pickupDate {
				IndexDomain: (i_route,i_cargo);
				Range: cal_days;
				Comment: "to be used for p_calc_loadingTimeCargoRoute.";
			}
			ElementParameter ep_calc_deliveryDate {
				IndexDomain: (i_route,i_cargo);
				Range: cal_days;
			}
			ElementParameter ep_calc_routeVessel {
				IndexDomain: i_route;
				Range: s_vessels;
			}
			ElementParameter ep_calc_routeLastLeg {
				IndexDomain: i_route;
				Range: s_calc_legs;
			}
			ElementParameter ep_calc_vesselActivityType {
				IndexDomain: (i_route, i_leg);
				Range: s_def_vesselActivities;
				webui::FlagsIdentifier: ui::sp_def_readOnly;
			}
			ElementParameter ep_calc_vesselActivityLocation {
				IndexDomain: (i_route,i_leg);
				Range: s_locations;
				Comment: {
					"For activities ep_vesselIdleWaitCargo and ep_vesselIdleRetired
					the location where the vessel is at.
					For activities ep_vesselSailingPickup  and ep_vesselSailingDelivery  the
					location where the vessel is sailing towards."
				}
				webui::FlagsIdentifier: ui::sp_def_readOnly;
			}
			ElementParameter ep_calc_vesselActivityFirst {
				IndexDomain: (i_route,i_leg);
				Range: cal_days;
				Comment: "First day of this vessel activity.";
				webui::FlagsIdentifier: ui::sp_def_readOnly;
			}
			ElementParameter ep_calc_vesselActivityLast {
				IndexDomain: (i_route,i_leg);
				Range: cal_days;
				webui::FlagsIdentifier: ui::sp_def_readOnly;
			}
			Parameter p_calc_arcsPerRoute {
				IndexDomain: (i_route,i_loc_from,i_loc_to);
				Range: binary;
			}
			Parameter p_def_vesselActivityLength {
				IndexDomain: (i_route,i_leg) | ep_calc_vesselActivityLast(i_route, i_leg);
				Unit: day;
				Definition: ((ep_calc_vesselActivityLast(i_route, i_leg) - ep_calc_vesselActivityFirst(i_route, i_leg)));
			}
			Parameter p_def_routeSailingDays {
				IndexDomain: i_route;
				Unit: day;
				Definition: {
					sum(i_leg | 
					        ep_calc_vesselActivityType(i_route, i_leg) = ep_def_vesselSailingPickup 
					        or ep_calc_vesselActivityType(i_route, i_leg) = ep_def_vesselSailingDelivery,
						p_def_vesselActivityLength(i_route, i_leg))
				}
			}
			Parameter p_def_routeIdleDays {
				IndexDomain: i_route;
				Unit: day;
				Definition: {
					sum( i_leg | 
						ep_calc_vesselActivityType(i_route, i_leg) = ep_def_vesselIdleWaitCargo or
						ep_calc_vesselActivityType(i_route, i_leg) = ep_def_vesselIdleRetired ,
						p_def_vesselActivityLength(i_route, i_leg) )
				}
			}
			Parameter p_def_routeSailingCost {
				IndexDomain: i_route;
				Unit: $;
				Definition: {
					p_def_routeSailingDays(i_route) 
					* p_sailingCost(ep_calc_routeVessel(i_route))
				}
			}
			Parameter p_def_visitingLocationCost {
				IndexDomain: i_route;
				Unit: $;
				Definition: {
					sum(i_leg | 
					        ep_calc_vesselActivityType(i_route, i_leg) = ep_def_vesselSailingPickup  
					        or ep_calc_vesselActivityType(i_route, i_leg) = ep_def_vesselSailingDelivery,
						p_adminCostAtLocation(ep_calc_vesselActivityLocation(i_route, i_leg)))
					+
					
					sum(i_leg | 
						    ep_calc_vesselActivityType(i_route, i_leg) = ep_def_vesselSailingPickup,
						p_loadingCostAtLocation(ep_calc_vesselActivityLocation(i_route, i_leg)))
				}
				Comment: {
					"The admin costs for visiting each location, and 
					the loading costs for visiting pickup locations."
				}
			}
			Parameter p_def_cargoCost {
				IndexDomain: i_route;
				Unit: $;
				Definition: {
					sum(i_cargo | 
					        i_cargo in s_calc_cargosHandled(i_route),
						p_cargoCost(i_cargo))
				}
			}
			Parameter p_def_routeIdleCost {
				IndexDomain: i_route;
				Unit: $;
				Definition: {
					sum(i_leg | 
					        ep_calc_vesselActivityType(i_route, i_leg) = ep_def_vesselIdleWaitCargo
					        or ep_calc_vesselActivityType(i_route, i_leg) = ep_def_vesselIdleRetired,
						p_def_vesselActivityLength(i_route, i_leg)
						* p_idleCostLocation(ep_calc_vesselActivityLocation(i_route, i_leg)))
				}
			}
			Parameter p_def_routeCosts {
				IndexDomain: i_route;
				Unit: $;
				Definition: {
					p_def_routeSailingCost(i_route) 
					+ p_def_visitingLocationCost(i_route) 
					+ p_def_cargoCost(i_route) 
					+ p_def_routeIdleCost(i_route)
				}
			}
			Parameter p_def_loadingTimeCargoRoute {
				IndexDomain: (i_act_cargo,i_route) | ep_calc_pickupDate(i_route, i_act_cargo);
				Unit: day;
				Definition: ep_calc_pickupDate(i_route, i_act_cargo) - ep_startHorizonDate;
				Comment: "the moment the cargo is loaded upon the vessel when it follows i_route.";
				webui::FlagsIdentifier: ui::sp_def_readOnly;
			}
			Parameter p_def_cargoesOnRoute {
				IndexDomain: (i_route,i_cargo);
				Range: nonnegative;
				Definition: 1 $ (i_cargo in s_calc_cargosHandled(i_route));
			}
			Parameter bp_def_cargoesOnRoute {
				IndexDomain: (i_route,i_act_cargo);
				Range: binary;
				Definition: 1 $ p_def_cargoesOnRoute(i_route,i_act_cargo);
			}
			Parameter p_def_deleveringTimeCargoRoute {
				IndexDomain: (i_act_cargo,i_route) | p_def_cargoesOnRoute(i_route,i_act_cargo);
				Unit: day;
				Definition: {
					(p_def_loadingTimeCargoRoute(i_act_cargo, i_route) 
					+ p_def_distanceBetweenLocations(ep_loadingPortsCargo(i_act_cargo), ep_deliveringPortsCargo(i_act_cargo)))
				}
				webui::FlagsIdentifier: ui::sp_def_readOnly;
			}
			Parameter bp_def_deliveringLocationsOnRoute {
				IndexDomain: (i_route,i_loc);
				Range: binary;
				Definition: {
					exists(i_leg | 
					    ep_calc_vesselActivityLocation(i_route, i_leg) = i_loc
					    and ep_calc_vesselActivityType(i_route, i_leg) = 'sailingDelivery')
				}
			}
			Parameter bp_def_loadingLocationsOnRoute {
				IndexDomain: (i_used_route,i_loc);
				Range: binary;
				Definition: {
					exists(i_leg | 
					    (ep_calc_vesselActivityLocation(i_used_route, i_leg) = i_loc
					    and ep_calc_vesselActivityType(i_used_route, i_leg) = 'sailingPickup'))
					
					or (ep_originPortOfVessel(ep_calc_routeVessel(i_used_route)) = i_loc
					    and i_loc = ep_calc_vesselActivityLocation(i_used_route, '1'))
				}
			}
			Procedure pr_calculateRoutesAndCost {
				Body: {
					! Determine horizon start (is read in via Excel inp).
					! Determine horizon length (is end - start) whereby
					! horizon end is defined as the last day for delivery of any cargo.
					
					! Empty route sets, and dependent identifiers.
					pr_initRoutes(); 
					
					! For each vessel, initialize to the empty route.
					pr_initRouteSetWithVesselsOnly();
					
					pr_processRouteList();
					
					! create arcs for map
					empty p_calc_arcsPerRoute;
					for (i_route) do
					    if sum(i_leg | ep_calc_vesselActivityLocation(i_route, i_leg), 1) = 1 then
					        skip;
					    endif;
					
					    for i_leg | ep_calc_vesselActivityLocation(i_route, i_leg) do
					        if ep_calc_vesselActivityLocation(i_route, i_leg - 1) = ep_calc_vesselActivityLocation(i_route, i_leg) then
					            skip;
					        endif;
					
					        p_calc_arcsPerRoute(i_route, ep_calc_vesselActivityLocation(i_route, i_leg - 1), ep_calc_vesselActivityLocation(i_route, i_leg)) := 1;
					    endfor;
					endfor;
					
					p_calc_arcsPerRoute(i_route, ep_originPortOfVessel(ep_calc_routeVessel(i_route)), ep_calc_vesselActivityLocation(i_route, '1')) |
					        (ep_originPortOfVessel(ep_calc_routeVessel(i_route)) <> ep_calc_vesselActivityLocation(i_route, '1'))
					:=  1;
				}
			}
			Procedure pr_initRoutes {
				Body: {
					empty s_calc_feasibleRoutes  ; ! Will also empty all identifiers declared over s_calc_routes.
					cleandependents s_calc_feasibleRoutes ; ! Will also empty the element space for s_calc_feasibleRoutes.
				}
				Comment: "Empty the route set, and its element space.";
			}
			Procedure pr_initRouteSetWithVesselsOnly {
				Body: {
					ep_loc_leg := first(s_calc_legs);
					
					! For each Vessel, a feasible route is to leave it in its berth.
					for i_act_vessel do
					
						! Create empty route for this vessel.
						SetElementAdd(s_calc_feasibleRoutes, ep_loc_newRoute, FormatString("%e", i_act_vessel));
					
						! Append the new route to the working list.
						s_temp_routeWorkingList += ep_loc_newRoute;
					
						! initialize globals for each new route.
						s_calc_cargosHandled(ep_loc_newRoute) := {};
					
						ep_temp_nextSailingDay(ep_loc_newRoute) := ep_startHorizonDate;
						ep_temp_lastLocation(ep_loc_newRoute) := ep_originPortOfVessel(i_act_vessel);
					
						ep_calc_routeVessel(ep_loc_newRoute) := i_act_vessel;
						ep_calc_routeLastLeg(ep_loc_newRoute) := ep_loc_leg;
						ep_calc_vesselActivityType(ep_loc_newRoute, ep_loc_leg) := ep_def_vesselIdleRetired;
						ep_calc_vesselActivityLocation(ep_loc_newRoute, ep_loc_leg) := ep_originPortOfVessel(i_act_vessel);
						ep_calc_vesselActivityFirst(ep_loc_newRoute, ep_loc_leg) := ep_startHorizonDate;
						ep_calc_vesselActivityLast(ep_loc_newRoute, ep_loc_leg) := ep_def_finishHorizonDate;
					endfor;
				}
				ElementParameter ep_loc_newRoute {
					Range: s_calc_feasibleRoutes;
				}
				ElementParameter ep_loc_leg {
					Range: s_calc_legs;
				}
			}
			Procedure pr_processRouteList {
				Body: {
					while card(s_temp_routeWorkingList) do
						ep_loc_workingRoute := first(s_temp_routeWorkingList);
						s_temp_routeWorkingList -= ep_loc_workingRoute ;
						pr_processSingleRoute(ep_loc_workingRoute);
					endwhile;
				}
				ElementParameter ep_loc_workingRoute {
					Range: s_calc_feasibleRoutes;
				}
			}
			Procedure pr_processSingleRoute {
				Arguments: (ep_in_workingRoute);
				Body: {
					! Earliest possible arrival:
					ep_loc_arrivalDay(i_act_cargo) 
					:=  ep_temp_nextSailingDay(ep_in_workingRoute) 
					    + p_def_distanceBetweenLocations(ep_temp_lastLocation(ep_in_workingRoute), ep_loadingPortsCargo(i_act_cargo))/1[day];
					
					! Earliest possible pickup - both vessel and cargo need to be present.
					ep_loc_pickupDay(i_act_cargo) := max(ep_loc_arrivalDay(i_act_cargo), ep_minTimeWindow(i_act_cargo));
					
					! Next sailing day - after pickup the sailing to the delivery:
					ep_loc_nextSailingDay(i_act_cargo) 
					:=  ep_loc_pickupDay(i_act_cargo) 
					    + p_def_distanceBetweenLocations(ep_loadingPortsCargo(i_act_cargo), ep_deliveringPortsCargo(i_act_cargo))/1[day];
					
					for i_act_cargo | 
					        (not (i_act_cargo in s_calc_cargosHandled(ep_in_workingRoute))) 
					        and (ep_loc_pickupDay(i_act_cargo) <= ep_maxTimeWindow(i_act_cargo)) 
					        and (ep_loc_nextSailingDay(i_act_cargo) <= ep_def_finishHorizonDate) do 
					
						! The name of the new route is the same as the old route, with the name of the cargo appended.
						sp_loc_newRoute := FormatString("%e_%e", ep_in_workingRoute, i_act_cargo);
					
						! Append this route to the collection of all routes, and to the working list.
						SetElementAdd(s_calc_feasibleRoutes, ep_loc_newRoute, sp_loc_newRoute);
						s_temp_routeWorkingList += ep_loc_newRoute;
					
						! Work the globals for this new route.
						s_calc_cargosHandled(ep_loc_newRoute) := s_calc_cargosHandled(ep_in_workingRoute);
						s_calc_cargosHandled(ep_loc_newRoute) += i_act_cargo;
						ep_temp_nextSailingDay(ep_loc_newRoute) := ep_loc_nextSailingDay(i_act_cargo);
						ep_temp_lastLocation(ep_loc_newRoute) := ep_deliveringPortsCargo(i_act_cargo);
						ep_calc_routeVessel(ep_loc_newRoute) := ep_calc_routeVessel(ep_in_workingRoute);
						ep_calc_pickupDate(ep_loc_newRoute, i_act_cargo_aux) := ep_calc_pickupDate(ep_in_workingRoute, i_act_cargo_aux);
						ep_calc_pickupDate(ep_loc_newRoute, i_act_cargo) := ep_loc_pickupDay(i_act_cargo);
					
						! First copy legs from working route to new route.
						ep_calc_routeLastLeg(ep_loc_newRoute) := ep_calc_routeLastLeg(ep_in_workingRoute);
						ep_calc_vesselActivityType(ep_loc_newRoute, i_leg) := ep_calc_vesselActivityType(ep_in_workingRoute, i_leg);
						ep_calc_vesselActivityLocation(ep_loc_newRoute, i_leg) := ep_calc_vesselActivityLocation(ep_in_workingRoute, i_leg);
						ep_calc_vesselActivityFirst(ep_loc_newRoute, i_leg) := ep_calc_vesselActivityFirst(ep_in_workingRoute, i_leg);
						ep_calc_vesselActivityLast(ep_loc_newRoute, i_leg) := ep_calc_vesselActivityLast(ep_in_workingRoute, i_leg);
					
						! Second, append the legs for handling i_act_cargo:
						! - sailing towards pickup location, 
						! - perhaps waiting for the cargo to become available, 
						! - sailing towards delivery location.
						ep_loc_lastLeg := ep_calc_routeLastLeg(ep_loc_newRoute);
						if ep_calc_vesselActivityType(ep_loc_newRoute, ep_loc_lastLeg) <> ep_def_vesselIdleRetired then
							raise warning 
								FormatString("internal error, each route should have a last leg for awaiting the end of the horizon. ep_loc_newRoute = %e, ep_loc_lastLeg = %e", 
									ep_loc_newRoute, ep_loc_lastLeg) ;
						endif;
					
						! last leg (idle-retired) will be replaced by sailing to pickup for i_act_cargo.
						if ep_temp_lastLocation(ep_in_workingRoute) <> ep_loadingPortsCargo(i_act_cargo)  then
							if ep_calc_vesselActivityType( ep_loc_newRoute, ep_loc_lastLeg ) <> ep_def_vesselIdleRetired then
								 ep_loc_lastLeg += 1;
							endif ;
							ep_loc_legSailingPickup := ep_loc_lastLeg ;
							ep_calc_vesselActivityType(ep_loc_newRoute, ep_loc_legSailingPickup ) := ep_def_vesselSailingPickup ;
							ep_calc_vesselActivityLocation( ep_loc_newRoute, ep_loc_legSailingPickup ) := ep_loadingPortsCargo(i_act_cargo) ;
							ep_calc_vesselActivityFirst(ep_loc_newRoute, ep_loc_legSailingPickup ) := ep_calc_vesselActivityFirst( ep_loc_newRoute, ep_loc_legSailingPickup ) ; ! so no change.
							ep_calc_vesselActivityLast(ep_loc_newRoute, ep_loc_legSailingPickup ) := ep_loc_arrivalDay( i_act_cargo ) ;
						endif ;
					
						if ep_loc_arrivalDay(i_act_cargo) < ep_minTimeWindow(i_act_cargo) then
							! need to wait for the cargo to become available in the pickup port.
							if ep_calc_vesselActivityType(ep_loc_newRoute, ep_loc_lastLeg) <> ep_def_vesselIdleRetired then
								ep_loc_lastLeg += 1;
							endif;
							ep_loc_legWaitingCargo := ep_loc_lastLeg;
							ep_calc_vesselActivityType(ep_loc_newRoute, ep_loc_legWaitingCargo) := ep_def_vesselIdleWaitCargo;
							ep_calc_vesselActivityLocation(ep_loc_newRoute, ep_loc_legWaitingCargo) := ep_loadingPortsCargo(i_act_cargo);
							ep_calc_vesselActivityFirst(ep_loc_newRoute, ep_loc_legWaitingCargo) := ep_loc_arrivalDay(i_act_cargo); 
							ep_calc_vesselActivityLast(ep_loc_newRoute, ep_loc_legWaitingCargo) := ep_minTimeWindow(i_act_cargo);
						endif ;
					
						ep_loc_lastLeg += 1;
						ep_loc_legSailingDelivery := ep_loc_lastLeg;
						ep_calc_vesselActivityType(ep_loc_newRoute, ep_loc_legSailingDelivery) := ep_def_vesselSailingDelivery;
						ep_calc_vesselActivityLocation(ep_loc_newRoute, ep_loc_legSailingDelivery) := ep_deliveringPortsCargo(i_act_cargo);
						ep_calc_vesselActivityFirst(ep_loc_newRoute, ep_loc_legSailingDelivery) := ep_loc_pickupDay(i_act_cargo); 
						ep_calc_vesselActivityLast(ep_loc_newRoute, ep_loc_legSailingDelivery) := ep_loc_nextSailingDay(i_act_cargo);
					
						ep_loc_lastLeg += 1;
						ep_loc_legIdleRetire := ep_loc_lastLeg;
						ep_calc_vesselActivityType(ep_loc_newRoute, ep_loc_legIdleRetire) := ep_def_vesselIdleRetired;
						ep_calc_vesselActivityLocation(ep_loc_newRoute, ep_loc_legIdleRetire) := ep_deliveringPortsCargo(i_act_cargo);
						ep_calc_vesselActivityFirst(ep_loc_newRoute, ep_loc_legIdleRetire) := ep_loc_nextSailingDay(i_act_cargo); 
						ep_calc_vesselActivityLast(ep_loc_newRoute, ep_loc_legIdleRetire) := ep_def_finishHorizonDate;
					
						ep_calc_routeLastLeg(ep_loc_newRoute) := ep_loc_lastLeg;
					
					endfor;
				}
				ElementParameter ep_in_workingRoute {
					Range: s_calc_feasibleRoutes;
					Property: Input;
				}
				ElementParameter ep_loc_arrivalDay {
					IndexDomain: i_cargo;
					Range: cal_days;
				}
				ElementParameter ep_loc_pickupDay {
					IndexDomain: i_cargo;
					Range: cal_days;
				}
				ElementParameter ep_loc_nextSailingDay {
					IndexDomain: i_cargo;
					Range: cal_days;
				}
				StringParameter sp_loc_newRoute;
				ElementParameter ep_loc_newRoute {
					Range: s_calc_feasibleRoutes;
				}
				ElementParameter ep_loc_lastLeg {
					Range: s_calc_legs;
				}
				ElementParameter ep_loc_legSailingPickup {
					Range: s_calc_legs;
				}
				ElementParameter ep_loc_legWaitingCargo {
					Range: s_calc_legs;
				}
				ElementParameter ep_loc_legSailingDelivery {
					Range: s_calc_legs;
				}
				ElementParameter ep_loc_legIdleRetire {
					Range: s_calc_legs;
				}
			}
		}
	}
	Procedure MainInitialization {
		Body: {
			ProfilerStart();
			
			pr_initCalendar;
		}
		Comment: "Add initialization statements here that do NOT require any library being initialized already.";
	}
	Procedure PostMainInitialization {
		Comment: {
			"Add initialization statements here that require that the libraries are already initialized properly,
			or add statements that require the Data Management module to be initialized."
		}
	}
	Procedure MainExecution {
		Body: {
			pr_calculateRoutesAndCost;
			
			solve mm::mp_vesselScheduling;
			
			ui::sp_systemWorkFlowSteps(1,8,'workflowPageState') := "active";
			ui::sp_systemWorkFlowSteps(1,9,'workflowPageState') := "active";
			ui::sp_systemWorkFlowSteps(1,10,'workflowPageState') := "active";
			
			!Changes statusbar
			ui::sp_systemStatusBar(2,'icon') := "aimms-checkmark-circle";
			ui::sp_systemStatusBar(2,'color') := "Green";
			ui::sp_systemStatusBar(2,'tooltip') := "The model has been solved.";
			
			!Open Overview dataset
			ui::sp_systemWorkflowFoldingStates(1, 4, 'openclose') := "close";
			
			!Post Execution
			mm::pr_post_vesselResults;
			mm::pr_post_cargoResults;
		}
	}
	Procedure PreMainTermination {
		Body: {
			return 1;!DataManagementExit();
		}
		Comment: {
			"Add termination statements here that require all libraries to be still alive.
			Return 1 if you allow the termination sequence to continue.
			Return 0 if you want to cancel the termination sequence."
		}
	}
	Procedure MainTermination {
		Body: {
			return 1;
		}
		Comment: {
			"Add termination statements here that do not require all libraries to be still alive.
			Return 1 to allow the termination sequence to continue.
			Return 0 if you want to cancel the termination sequence.
			It is recommended to only use the procedure PreMainTermination to cancel the termination sequence and let this procedure always return 1."
		}
	}
}
