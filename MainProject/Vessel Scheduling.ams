## ams_version=1.0

Model Main_Vessel_Schedule {
	Section Data_Model {
		Section Quantities_and_Units {
			Comment: {
				"This section contains all the units and quantities that are added automatically by AIMMS.
				It is recommended to declare all your quantities here."
			}
			Quantity SI_Time_Duration {
				BaseUnit: s;
				Conversions: {
					day->s : #-># * 86400,
					minute->s : #-># * 60
				}
				Comment: {
					"Expresses the value for the duration of periods.
					
					The unit s has been added automatically because it is a required unit for AimmsWebUI.
					
					The unit minute has been added automatically because it is a required unit for AimmsWebUI.
					
					The unit minute has been added automatically because it is a required unit for AimmsWebUI."
				}
			}
			Quantity Q_Currency {
				BaseUnit: $;
			}
		}
		Section Calendars {
			Calendar cal_days {
				Index: i_day;
				Unit: day;
				BeginDate: sp_def_beginDate;
				EndDate: sp_def_endDate;
				TimeslotFormat: "%c%y-%m-%d";
			}
			ElementParameter ep_startHorizonDate {
				Range: cal_days;
			}
			StringParameter sp_def_beginDate {
				Definition: "2000-01-01";
			}
			StringParameter sp_def_endDate {
				Definition: "2099-12-31";
			}
		}
		Section Cargoes {
			Set s_cargoes {
				Index: i_cargo_aux;
				Parameter: ep_cargo;
			}
			Index i_cargo {
				Range: s_cargoes;
				dex::ColumnName: Cargo;
			}
			Set s_def_activeCargoes {
				SubsetOf: s_cargoes;
				Index: i_act_cargo, i_act_cargo_aux;
				Definition: {
					{i_cargo | bp_activeCargoes(i_cargo)}
				}
			}
			Parameter bp_activeCargoes {
				IndexDomain: i_cargo;
				Range: binary;
				InitialData: 1;
			}
			Parameter p_spotCostVessel {
				IndexDomain: i_cargo;
				Unit: $;
				Comment: "todo: what this is?";
				dex::ColumnName: Spotcost on Vessel;
				dex::Dataset: Import;
				dex::TableName: CargoData;
			}
			ElementParameter ep_MinTimeWindow {
				IndexDomain: i_cargo;
				Range: cal_days;
				Comment: "todo: what this is?";
				dex::ColumnName: Minimum Loading Time;
				dex::Dataset: Import;
				dex::TableName: CargoData;
			}
			ElementParameter ep_MaxTimeWindow {
				IndexDomain: i_cargo;
				Range: cal_days;
				Comment: "todo: what this is?";
				dex::ColumnName: Maximum Loading Time;
				dex::Dataset: Import;
				dex::TableName: CargoData;
			}
			ElementParameter ep_LoadingPortsCargo {
				IndexDomain: i_cargo;
				Range: s_locations;
				Comment: "todo: not on screen";
				dex::ColumnName: Loading Port;
				dex::Dataset: Import;
				dex::TableName: CargoData;
			}
			ElementParameter ep_DeliveringPortsCargo {
				IndexDomain: i_cargo;
				Range: s_locations;
				Comment: "todo: not on screen";
				dex::ColumnName: Delevering Port;
				dex::Dataset: Import;
				dex::TableName: CargoData;
			}
		}
		Section Vessels {
			Set s_vessels {
				Parameter: ep_vessel;
			}
			Index i_vessel {
				Range: s_vessels;
				dex::ColumnName: Vessel;
			}
			Set s_def_activeVessels {
				SubsetOf: s_vessels;
				Index: i_act_vessel;
				Definition: {
					{i_vessel | bp_activeVessels(i_vessel)}
				}
			}
			Parameter bp_activeVessels {
				IndexDomain: i_vessel;
				Range: binary;
				InitialData: 1;
			}
			ElementParameter ep_originPortOfVessel {
				IndexDomain: i_vessel;
				Range: s_locations;
				dex::ColumnName: Port of Origin;
				dex::Dataset: Import;
				dex::TableName: VesselData;
			}
			Parameter p_def_idleCostVesselNotUsed {
				IndexDomain: i_vessel;
				Unit: $;
				Definition: {
					! Location vessel multiply max time horizon
					p_IdleCostLocation(ep_originPortOfVessel(i_vessel)) 
					* max(i_cargo, p_MaxTimeWindow(i_cargo));
				}
				Comment: "todo: check if makes sense";
			}
		}
		Section Cost_Types {
			Set s_costTypes {
				Parameter: ep_costType;
			}
			Index i_ct {
				Range: s_costTypes;
				dex::ColumnName: Cost Type;
			}
			Set s_def_costTypesForCargoes {
				SubsetOf: s_costTypes;
				Index: i_ct_cargo;
				Definition: {
					{i_ct | bp_activeCostsForCargoes(i_ct)}
				}
			}
			Parameter bp_activeCostsForCargoes {
				IndexDomain: i_ct;
				Range: binary;
				dex::ColumnName: Cargoes;
				dex::Dataset: Import;
				dex::TableName: Type Cost Group;
			}
			Set s_def_costTypesForVessels {
				SubsetOf: s_costTypes;
				Index: i_ct_vessel;
				Definition: {
					{i_ct | bp_activeCostsForVessels(i_ct)}
				}
			}
			Parameter bp_activeCostsForVessels {
				IndexDomain: i_ct;
				Range: binary;
				dex::ColumnName: Vessel;
				dex::Dataset: Import;
				dex::TableName: Type Cost Group;
			}
			Set s_def_costTypesForLocations {
				SubsetOf: s_costTypes;
				Index: i_ct_loc;
				Definition: {
					{i_ct | bp_activeCostsForLocations(i_ct)}
				}
			}
			Parameter bp_activeCostsForLocations {
				IndexDomain: i_ct;
				Range: binary;
				dex::ColumnName: Location;
				dex::Dataset: Import;
				dex::TableName: Type Cost Group;
			}
		}
		Section Locations {
			Set s_locations {
				Parameter: ep_location;
			}
			Index i_loc {
				Range: s_locations;
				dex::ColumnName: Location;
			}
			Index i_loc_from {
				Range: s_locations;
				dex::ColumnName: Location (From);
			}
			Index i_loc_to {
				Range: s_locations;
				dex::ColumnName: Location (To);
			}
			Parameter p_latitude {
				IndexDomain: i_loc;
				dex::ColumnName: Latitude;
				dex::Dataset: Import;
				dex::TableName: LocationData;
			}
			Parameter p_longitude {
				IndexDomain: i_loc;
				dex::ColumnName: Longitude;
				dex::Dataset: Import;
				dex::TableName: LocationData;
			}
			Parameter p_idleCostLocation {
				IndexDomain: i_loc;
				Unit: $/day;
				dex::ColumnName: Idle Cost;
				dex::Dataset: Import;
				dex::TableName: LocationData;
			}
		}
		Section Section_1 {
			Parameter p_LocationCost {
				IndexDomain: (i_loc,i_ct) | bp_activeCostsForLocations(i_ct);
				Unit: $;
				Definition: {
					!Hoe wordt dit in de webui teruggeven
					!sum(i_CostType |
				}
				dex::ColumnName: Costs;
				dex::Dataset: Import;
				dex::TableName: LocationCosts;
			}
			Parameter p_CargoCost {
				IndexDomain: (i_cargo,i_ct) | bp_activeCostsForCargoes(i_ct);
				Range: free;
				Unit: $;
				dex::ColumnName: Type Costs;
				dex::Dataset: Import;
				dex::TableName: CargoCosts;
			}
			Parameter p_VesselCostDay {
				IndexDomain: (i_vessel,i_ct) | bp_activeCostsForVessels(i_ct);
				Unit: $/day;
				Comment: {
					"! Fuel usage per day is 63000 gallons = 238000 liter -> 238000/100000 * â‚¬601 = 1433"
				}
				dex::ColumnName: DailyCost;
				dex::Dataset: Import;
				dex::TableName: VesselCosts;
			}
		}
		Section Routes {
			Procedure pr_calculateRoutesAndCost {
				Body: {
					empty s_FeasibleRoutes;
					empty p_CargoesOnRoute;
					
					!Assumption: when a vessel is used, and the time horizon starts, 
					!the vessel will always directly move to the loading port of the cargo.
					
					for i_act_vessel do
					
					    !Resetten van LoopCount
					    p_LoopCount := 1;
					
					    for i_act_cargo do
					
					        if 
					        p_DistanceBetweenLocations(ep_originPortOfVessel(i_act_vessel),ep_LoadingPortsCargo(i_act_cargo))<=p_MinTimeWindow(i_act_cargo)
					        then
					
					            setelementadd(s_FeasibleRoutes,ep_route,i_act_vessel + "_" + i_act_cargo);
					
					            !Cannot come earlier then arrival time
					            p_LastLoadArrivalTime(ep_route) := p_MinTimeWindow(i_act_cargo);
					            ep_LastCargoFromRoute(ep_route) := i_act_cargo;
					            ep_VesselOnRoute(ep_route) := i_act_vessel;
					            p_CargoesOnRoute(ep_route, i_act_cargo) := 1;
					            p_QuantityCargos(ep_route) := 1;
					
					            !Loading and delivering time
					            p_LoadingTimeCargoRoute(i_act_cargo, ep_route) := p_MinTimeWindow(i_act_cargo);
					
					            !Add cargoes to route
					            sp_CargoesOnRoute(ep_route) := i_act_cargo;
					
					            !Extra deliver arrival time
					            p_LastDeliverArrivalTime(ep_route) := p_LastLoadArrivalTime(ep_route) + 
					               p_DistanceBetweenLocations(ep_LoadingPortsCargo(i_act_cargo),ep_DeliveringPortsCargo(i_act_cargo));
					
					            !Idle cost per route first cargo
					            p_TotalRouteIdleCost(ep_route) := p_IdleCostLocation(ep_LoadingPortsCargo(i_act_cargo)) * 
					            (p_MinTimeWindow(i_act_cargo)-p_DistanceBetweenLocations(ep_originPortOfVessel(i_act_vessel),ep_LoadingPortsCargo(i_act_cargo)));
					
					            !Cost for first movement
					            p_TotalDaysTravel(ep_route) := p_DistanceBetweenLocations(ep_originPortOfVessel(i_act_vessel),ep_LoadingPortsCargo(i_act_cargo))+
					            p_DistanceBetweenLocations(ep_LoadingPortsCargo(i_act_cargo), ep_DeliveringPortsCargo(i_act_cargo));
					
					            !Cost for first location
					            p_TotalRouteLocationCost(ep_route) := sum(i_ActiveCostType, p_LocationCost(ep_LoadingPortsCargo(i_act_cargo),i_ActiveCostType)+
					                p_LocationCost(ep_DeliveringPortsCargo(i_act_cargo),i_ActiveCostType));
					
					            !Cost for first cargo
					            p_TotalRouteCargoCost(ep_route) := sum(i_ActiveCostType, p_CargoCost(i_act_cargo, i_ActiveCostType));
					
					        elseif
					        p_MinTimeWindow(i_act_cargo) <= p_DistanceBetweenLocations(ep_originPortOfVessel(i_act_vessel),ep_LoadingPortsCargo(i_act_cargo)) <= p_MaxTimeWindow(i_act_cargo)
					        then
					
					            setelementadd(s_FeasibleRoutes,ep_route,i_act_vessel + "_" + i_act_cargo);
					
					            !Cannot come earlier then arrival time
					            p_LastLoadArrivalTime(ep_route) := p_DistanceBetweenLocations(ep_originPortOfVessel(i_act_vessel),ep_LoadingPortsCargo(i_act_cargo));
					            ep_LastCargoFromRoute(ep_route) := i_act_cargo;
					            ep_VesselOnRoute(ep_route) := i_act_vessel;
					            p_CargoesOnRoute(ep_route, i_act_cargo) := 1;
					            p_QuantityCargos(ep_route) := 1;
					
					            !Loading and delivering time
					            p_LoadingTimeCargoRoute(i_act_cargo, ep_route) := p_DistanceBetweenLocations(ep_originPortOfVessel(i_act_vessel),ep_LoadingPortsCargo(i_act_cargo));
					
					            !Add cargoes to route
					            sp_CargoesOnRoute(ep_route) := i_act_cargo;
					
					            !Extra deliver arrival time
					            p_LastDeliverArrivalTime(ep_route) := p_LastLoadArrivalTime(ep_route) + 
					               p_DistanceBetweenLocations(ep_LoadingPortsCargo(i_act_cargo),ep_DeliveringPortsCargo(i_act_cargo));
					
					            !Cost for first movement
					            p_TotalDaysTravel(ep_route) := p_DistanceBetweenLocations(ep_originPortOfVessel(i_act_vessel),ep_LoadingPortsCargo(i_act_cargo))+
					            p_DistanceBetweenLocations(ep_LoadingPortsCargo(i_act_cargo), ep_DeliveringPortsCargo(i_act_cargo));
					
					            !Cost for first location
					            p_TotalRouteLocationCost(ep_route) := sum(i_ActiveCostType, p_LocationCost(ep_LoadingPortsCargo(i_act_cargo),i_ActiveCostType)+
					                p_LocationCost(ep_DeliveringPortsCargo(i_act_cargo),i_ActiveCostType));
					
					            !Cost for first cargo
					            p_TotalRouteCargoCost(ep_route) := sum(i_ActiveCostType, p_CargoCost(i_act_cargo, i_ActiveCostType));
					
					        endif;
					    endfor;
					
					    repeat 
					
					        !Selecteer alle routes die gelijk zijn aan de loopcount en aan de juiste vessel
					        s_sub_routes := {i_route | p_QuantityCargos(i_route) = p_LoopCount and ep_VesselOnRoute(i_route) = i_act_vessel}; 
					
					        !Statement to break out of the loop
					        if card(s_sub_routes)=0 then
					
					            break;
					
					        endif;
					
					        for i_sub_rout do
					
					            !Only cargoes that are not on the route yet
					            for i_act_cargo | p_CargoesOnRoute(i_sub_rout, i_act_cargo) = 0 do  
					
					                if 
					                p_TravelTimeCargoes(ep_LastCargoFromRoute(i_sub_rout),i_act_cargo) + p_LastLoadArrivalTime(i_sub_rout) <= p_MinTimeWindow(i_act_cargo)
					                then
					
					                    setelementadd(s_FeasibleRoutes,ep_route,i_sub_rout + "_" + i_act_cargo);
					
					                    p_LastLoadArrivalTime(ep_route) := p_MinTimeWindow(i_act_cargo);
					                    ep_LastCargoFromRoute(ep_route) := i_act_cargo;
					                    ep_VesselOnRoute(ep_route) := i_act_vessel;
					                    p_QuantityCargos(ep_route) := p_LoopCount+1;
					                    p_CargoesOnRoute(ep_route, i_act_cargo_aux) := p_CargoesOnRoute(i_sub_rout, i_act_cargo_aux);
					                    p_CargoesOnRoute(ep_route, i_act_cargo) := p_QuantityCargos(ep_route);
					
					                    !Loading and delivering time
					                    p_LoadingTimeCargoRoute(i_act_cargo_aux, ep_route) :=  p_LoadingTimeCargoRoute(i_act_cargo_aux, i_sub_rout);
					                    p_LoadingTimeCargoRoute(i_act_cargo, ep_route) :=  p_MinTimeWindow(i_act_cargo);
					
					                    !Add cargoes to route
					                    sp_CargoesOnRoute(ep_route) := sp_CargoesOnRoute(i_sub_rout)+","+i_act_cargo;
					
					                    !Extra deliver arrival time
					                    p_LastDeliverArrivalTime(ep_route) := p_LastLoadArrivalTime(ep_route) + 
					                       p_DistanceBetweenLocations(ep_LoadingPortsCargo(i_act_cargo),ep_DeliveringPortsCargo(i_act_cargo));
					
					                    !Idle cost per route next cargoes
					                    p_TotalRouteIdleCost(ep_route) := p_TotalRouteIdleCost(i_sub_rout) + p_IdleCostLocation(ep_LoadingPortsCargo(i_act_cargo)) * 
					                    (p_MinTimeWindow(i_act_cargo)-(p_TravelTimeCargoes(ep_LastCargoFromRoute(i_sub_rout),i_act_cargo) + p_LastLoadArrivalTime(i_sub_rout)));
					
					                    !Cost for the other movements
					                    p_TotalDaysTravel(ep_route) := p_TotalDaysTravel(i_sub_rout)+
					                        p_DistanceBetweenLocations(ep_DeliveringPortsCargo(ep_LastCargoFromRoute(ep_route)),ep_LoadingPortsCargo(i_act_cargo))+
					                        p_DistanceBetweenLocations(ep_LoadingPortsCargo(i_act_cargo), ep_DeliveringPortsCargo(i_act_cargo));
					
					                    !Cost for the other locations
					                    if ep_DeliveringPortsCargo(ep_LastCargoFromRoute(i_sub_rout)) <> ep_LoadingPortsCargo(i_act_cargo) then
					                        p_TotalRouteLocationCost(ep_route) := p_TotalRouteLocationCost(i_sub_rout)+
					                        sum(i_ActiveCostType,  p_LocationCost(ep_LoadingPortsCargo(i_act_cargo),i_ActiveCostType) +
					                        p_LocationCost(ep_DeliveringPortsCargo(i_act_cargo),i_ActiveCostType));
					                    else 
					                        p_TotalRouteLocationCost(ep_route) := p_TotalRouteLocationCost(i_sub_rout)+
					                        sum(i_ActiveCostType,p_LocationCost(ep_DeliveringPortsCargo(i_act_cargo),i_ActiveCostType));                                
					                    endif;                
					
					                    !Cost for the other cargoes
					                    p_TotalRouteCargoCost(ep_route) := p_TotalRouteCargoCost(i_sub_rout)+
					                    sum(i_ActiveCostType, p_CargoCost(i_act_cargo, i_ActiveCostType));
					
					                elseif 
					                p_MinTimeWindow(i_act_cargo) <= p_TravelTimeCargoes(ep_LastCargoFromRoute(i_sub_rout),i_act_cargo) + 
					                p_LastLoadArrivalTime(i_sub_rout) <= p_MaxTimeWindow(i_act_cargo)
					                then
					
					                    setelementadd(s_FeasibleRoutes,ep_route,i_sub_rout + "_" + i_act_cargo);
					                    p_LastLoadArrivalTime(ep_route) := p_TravelTimeCargoes(ep_LastCargoFromRoute(i_sub_rout),i_act_cargo) + p_LastLoadArrivalTime(i_sub_rout);
					                    ep_LastCargoFromRoute(ep_route) := i_act_cargo;
					                    ep_VesselOnRoute(ep_route) := i_act_vessel;
					                    p_QuantityCargos(ep_route) := p_LoopCount+1;
					                    p_CargoesOnRoute(ep_route, i_act_cargo_aux) := p_CargoesOnRoute(i_sub_rout, i_act_cargo_aux);
					                    p_CargoesOnRoute(ep_route, i_act_cargo) :=  p_QuantityCargos(ep_route);
					
					                    !Loading and delivering time
					                    p_LoadingTimeCargoRoute(i_act_cargo_aux, ep_route) :=  p_LoadingTimeCargoRoute(i_act_cargo_aux, i_sub_rout);
					                    p_LoadingTimeCargoRoute(i_act_cargo, ep_route) :=  p_TravelTimeCargoes(ep_LastCargoFromRoute(i_sub_rout),i_act_cargo) + 
					                        p_LastLoadArrivalTime(i_sub_rout);
					
					                    !Add cargoes to route
					                    sp_CargoesOnRoute(ep_route) := sp_CargoesOnRoute(i_sub_rout)+","+i_act_cargo;
					
					                    !Extra deliver arrival time
					                    p_LastDeliverArrivalTime(ep_route) := p_LastLoadArrivalTime(ep_route) + 
					                       p_DistanceBetweenLocations(ep_LoadingPortsCargo(i_act_cargo),ep_DeliveringPortsCargo(i_act_cargo));
					
					                    !Cost for the other movements
					                    p_TotalDaysTravel(ep_route) := p_TotalDaysTravel(i_sub_rout)+
					                        p_DistanceBetweenLocations(ep_DeliveringPortsCargo(ep_LastCargoFromRoute(ep_route)),ep_LoadingPortsCargo(i_act_cargo))+
					                        p_DistanceBetweenLocations(ep_LoadingPortsCargo(i_act_cargo), ep_DeliveringPortsCargo(i_act_cargo));
					
					                    !Cost for the other locations
					                    if ep_DeliveringPortsCargo(ep_LastCargoFromRoute(i_sub_rout)) <> ep_LoadingPortsCargo(i_act_cargo) then
					                        p_TotalRouteLocationCost(ep_route) := p_TotalRouteLocationCost(i_sub_rout)+
					                        sum(i_ActiveCostType,  p_LocationCost(ep_LoadingPortsCargo(i_act_cargo),i_ActiveCostType) +
					                        p_LocationCost(ep_DeliveringPortsCargo(i_act_cargo),i_ActiveCostType));
					                    else 
					                        p_TotalRouteLocationCost(ep_route) := p_TotalRouteLocationCost(i_sub_rout)+
					                        sum(i_ActiveCostType,p_LocationCost(ep_DeliveringPortsCargo(i_act_cargo),i_ActiveCostType));                                
					                    endif;                
					
					                    !Cost for the other cargoes
					                    p_TotalRouteCargoCost(ep_route) := p_TotalRouteCargoCost(i_sub_rout)+
					                    sum(i_ActiveCostType, p_CargoCost(i_act_cargo, i_ActiveCostType));
					
					                endif;
					
					            endfor;
					
					        endfor;
					
					    p_LoopCount += 1;
					
					    endrepeat;
					
					endfor;
					
					!Add the idle cost of a ship staying in the port of delevering
					for i_route do
					
					    if max(i_cargo,p_MaxTimeWindow(i_cargo))-p_LastLoadArrivalTime(i_route)>=0[day] then
					
					        p_TotalRouteIdleCost(i_route) += ((max(i_cargo,p_MaxTimeWindow(i_cargo))-p_LastLoadArrivalTime(i_route)))*
					           p_IdleCostLocation(ep_DeliveringPortsCargo(ep_LastCargoFromRoute(i_route)));
					
					    endif;
					endfor;
					
					!Activate solve button
					ui::sp_systemSecondaryActions(4,'state'):= 'active';
					
					!Changes to status bar
					ui::sp_systemStatusBar(2,'icon') := "aimms-checkmark-circle";
					ui::sp_systemStatusBar(2,'color') := "Green";
					ui::sp_systemStatusBar(2,'tooltip') := "The routes are succesfully generated.";
					ui::sp_systemStatusBar(3,'color') := "Orange";
					ui::sp_systemStatusBar(3,'icon'):= "aimms-circle2";
					ui::sp_systemStatusBar(3,'tooltip') := "Data is ready, time to solve!";
					ui::sp_systemStatusBar(3,'state'):="active";
				}
				Set s_sub_routes {
					SubsetOf: s_FeasibleRoutes;
					Index: i_sub_rout;
				}
				Parameter p_LoopCount;
			}
			ElementParameter ep_vesselOnRoute {
				IndexDomain: i_route;
				Range: s_def_activeVessels;
				webui::FlagsIdentifier: sp_ReadsOnly;
			}
			ElementParameter ep_LastCargoFromRoute {
				IndexDomain: i_route;
				Range: s_cargoes;
			}
			Parameter p_LastLoadArrivalTime {
				IndexDomain: i_route;
				Unit: day;
			}
			Parameter p_LastDeliverArrivalTime {
				IndexDomain: i_route;
				Unit: day;
			}
			Parameter p_QuantityCargos {
				IndexDomain: i_route;
			}
			Parameter p_TotalDaysTravel {
				IndexDomain: i_route;
				Unit: day;
				webui::FlagsIdentifier: sp_ReadsOnly;
			}
			Parameter p_TotalRouteIdleCost {
				IndexDomain: (i_route);
				Unit: $;
			}
			Parameter p_TotalRouteMovementCost {
				IndexDomain: i_route;
				Unit: $;
				Definition: p_TotalDaysTravel(i_route) * sum(i_ct, p_VesselCostDay(ep_VesselOnRoute(i_route),i_ct));
			}
			Parameter p_TotalRouteLocationCost {
				IndexDomain: i_route;
				Unit: $;
			}
			Parameter p_TotalRouteCargoCost {
				IndexDomain: i_route;
				Unit: $;
			}
			Parameter p_OperationalCostVessel {
				IndexDomain: i_route;
				Unit: $;
				Definition: {
					!p_IdleCostUsedVessel(i_route)+p_TaxesCostRoute(i_route)+p_DailyCostRoute(i_route)+p_FuelCostRoute(i_route)
					p_TotalRouteCargoCost(i_route)+p_TotalRouteLocationCost(i_route)+p_TotalRouteIdleCost(i_route)+p_TotalRouteMovementCost(i_route)
				}
			}
		}
		Section InputModel {
			Parameter p_MinTimeWindow {
				IndexDomain: i_cargo;
				Unit: day;
				Definition: StringToMoment("%c%y-%m-%d",[day],ep_StartHorizonDate,ep_MinTimeWindow(i_cargo));
				Comment: {
					"!Change the table name if the indices 
					!"
				}
			}
			Parameter p_MaxTimeWindow {
				IndexDomain: i_cargo;
				Unit: day;
				Definition: StringToMoment("%c%y-%m-%d",[day],ep_StartHorizonDate,ep_MaxTimeWindow(i_cargo));
			}
			Procedure pr_ImportDataExcel {
				Body: {
					dex::GenerateDatasetMappings;
					
					!Delete old data
					pr_DeleteData;
					
					!Importeren van de data
					dex::AddMapping(
					    mappingName : "ImportData", 
					    mappingFile : "./Mappings/Generated/Import-Excel.xml");
					
					dex::ReadFromFile(
					    dataFile : "data\\DataForImport_test_v2.xlsx", !Uiteindelijke variant DataForImport.xlsx
					    mappingName : "ImportData");
					
					!Activate all master data
					bp_activeCargoes(i_cargo):= 1;
					bp_activeVessels(i_vessel) := 1;
					ui::p_AllocatedCargoes(i_act_cargo) :=1;
					
					!Activate generating routes
					ui::sp_systemSecondaryActions(3,'state'):= 'active';
					
					!Changes to status bar
					ui::sp_systemStatusBar(1,'icon') := "aimms-checkmark-circle";
					ui::sp_systemStatusBar(1,'color') := "Green";
					ui::sp_systemStatusBar(1,'tooltip') := "Data is succesfully imported.";
					ui::sp_systemStatusBar(2,'color') := "Orange";
					ui::sp_systemStatusBar(2,'icon'):= "aimms-circle2";
					ui::sp_systemStatusBar(2,'tooltip') := "Application ready to generate routes.";
					ui::sp_systemStatusBar(2,'state') := "active";
					ui::sp_systemStatusBar(3,'color') := "red";
					ui::sp_systemStatusBar(3,'icon') := "aimms-cancel-circle2";
					ui::sp_systemStatusBar(3,'tooltip') := "Model not ready to be solved.";
					ui::sp_systemStatusBar(3,'state') := 'inactive';
					
					!Open Overview dataset
					ui::sp_systemWorkflowFoldingStates(1, 4, 'openclose') := "open";
				}
			}
			Procedure pr_GenerateMappingFile {
				Body: {
					dex::GenerateDatasetMappings;
				}
			}
			DeclarationSection Declaration_Import_Out_Excel {
				Parameter p_DistanceBetweenLocations {
					IndexDomain: (i_loc_from,i_loc_to)| i_loc_from <> i_loc_to;
					Unit: day;
					dex::ColumnName: DeleveringLocation;
					dex::Dataset: Import;
					dex::TableName: DistanceBetweenLocations;
				}
			}
			DeclarationSection Declaration_Routes {
				Set s_FeasibleRoutes {
					Index: i_route;
					Parameter: ep_route;
				}
				Parameter p_TravelTimeCargoes {
					IndexDomain: (i_cargo,i_cargo_aux) | (i_cargo<>i_cargo_aux);
					Unit: day;
					Definition: {
						!13,5 knots = 25 km/h
						!1 day = 600km
						p_DistanceBetweenLocations(ep_LoadingPortsCargo(i_cargo),ep_DeliveringPortsCargo(i_cargo)) +
						p_DistanceBetweenLocations(ep_DeliveringPortsCargo(i_cargo),ep_LoadingPortsCargo(i_cargo_aux))
					}
				}
				Parameter p_CargoesOnRouteBin {
					IndexDomain: (i_route,i_cargo);
					Range: binary;
					Definition: {
						p_CargoesOnRoute(i_route, i_cargo)>0;
					}
				}
				Parameter p_CargoesOnRoute {
					IndexDomain: (i_route,i_cargo);
					Range: nonnegative;
				}
			}
		}
		Section OutputModel {
			Procedure pr_ExportData {
				Body: {
					dex::AddMapping(
					    mappingName : "Import",
					    mappingFile : "./Mappings/Generated/Import-Excel.xml");
					
					dex::WriteToFile(
					    dataFile : "data\\FormatDataScheduling.xlsx",
					    mappingName : "Import");
				}
			}
			Procedure pr_determineCargoOnVessel {
				Body: {
					for (i_allcRoute,i_cargo) | (StringOccurrences(sp_CargoesOnRoute(i_allcRoute),i_cargo)=1) do
					    ep_CargoOnVessel(i_cargo) := ep_VesselOnRoute(i_allcRoute);
					endfor;
				}
			}
			Procedure pr_determineLoadingAndDelivering {
				Body: {
					for i_allcRoute do
					
					    p_LoadingTimeCargo(i_act_cargo) | 
					            p_CargoesOnRouteBin(i_allcRoute, i_act_cargo) 
					    := p_LoadingTimeCargoRoute(i_act_cargo, i_allcRoute);
					
					    p_DeleveringTimeCargo(i_act_cargo) | 
					            p_CargoesOnRouteBin(i_allcRoute, i_act_cargo) 
					    := p_DeleveringTimeCargoRoute(i_act_cargo, i_allcRoute);
					
					endfor;
				}
			}
			Procedure pr_DeleteData {
				Body: {
					CaseFileLoad("data\\StandardWebUI.data");
				}
			}
			Procedure pr_ConvertToDate {
				Body: {
					for i_allcRoute do   
					
					    sp_LoadingTimeCargoRoute(i_act_cargo) | 
					            p_CargoesOnRouteBin(i_allcRoute, i_act_cargo)
					    :=  MomentToString("%d/%m/%y", [day], ep_StartHorizonDate, p_LoadingTimeCargoRoute(i_act_cargo, i_allcRoute));
					
					    sp_DeleveringTimeCargoRoute(i_act_cargo) | 
					            p_CargoesOnRouteBin(i_allcRoute, i_act_cargo)
					    :=  MomentToString("%d/%m/%y",[day], ep_StartHorizonDate, p_DeleveringTimeCargoRoute(i_act_cargo, i_allcRoute));        
					
					endfor;
				}
			}
			DeclarationSection Declaration_Results {
				Set s_allocatedRoutes {
					SubsetOf: s_FeasibleRoutes;
					Index: i_allcRoute;
					Parameter: ep_allcRoute;
					Definition: {
						{(i_route) | exists((i_act_vessel) | mm::v_AllocateVesselToRoute(i_act_vessel, i_route))};
					}
				}
				Parameter p_Allocatedroutes {
					IndexDomain: i_allcRoute;
					webui::UponChangeProcedure: pr_CalculateAllArcs;
				}
				Parameter p_LoadingTimeCargo {
					IndexDomain: i_act_cargo;
					Unit: day;
				}
				Parameter p_DeleveringTimeCargo {
					IndexDomain: i_act_cargo;
					Unit: day;
				}
				Parameter p_CargoCostRoute {
					IndexDomain: i_act_cargo;
					Unit: $;
					Definition: {
						if i_act_cargo $ mm::v_CargoOnCharteredVessel(i_act_cargo) then
						    p_SpotCostVessel(i_act_cargo)
						else 
						    sum(i_ActiveCostType, p_CargoCost(i_act_cargo, i_ActiveCostType))
						endif;
					}
					webui::FlagsIdentifier: sp_ReadsOnly;
				}
				ElementParameter ep_CargoOnVessel {
					IndexDomain: i_act_cargo;
					Range: s_vessels;
					Definition: {
						pr_determineCargoOnVessel;
					}
					Comment: "sp_CargoesOnRoute(i_allcRoute)";
					webui::FlagsIdentifier: sp_ReadsOnly;
				}
				StringParameter sp_CargoesOnRoute {
					IndexDomain: i_route;
					webui::FlagsIdentifier: sp_ReadsOnly;
				}
			}
		}
	}
	Section WebUIVessel {
		Procedure pr_LegendRouteViz {
			Body: {
				for i_CargLocLoadRoute do
				    setelementadd(s_SortPortsRouteVis,ep_SortPortsRouteVis,sp_PortsVisualisationPageAnnotation(i_CargLocLoadRoute));
				endfor;
				
				for i_CargLocDelRoute do   
				    setelementadd(s_SortPortsRouteVis,ep_SortPortsRouteVis,sp_PortsVisualisationPageAnnotation(i_CargLocDelRoute));   
				endfor;
				
				for i_VesselPortOrigin do
				    setelementadd(s_SortPortsRouteVis,ep_SortPortsRouteVis,sp_PortsVisualisationPageAnnotation(i_VesselPortOrigin)); 
				endfor;
			}
		}
		Procedure pr_LegendCargoViz {
			Body: {
				for ui::i_CargoLocLoad do
				    setelementadd(s_SortOfPortsCargo,ep_SortOfPortsCargo,sp_PortsCargoPageAnnotation(ui::i_CargoLocLoad));
				endfor;
				
				for ui::i_CargoLocDel do   
				    setelementadd(s_SortOfPortsCargo,ep_SortOfPortsCargo,sp_PortsCargoPageAnnotation(ui::i_CargoLocDel));   
				endfor;
			}
		}
		Procedure pr_DeselectCargoes {
			Body: {
				ui::p_AllocatedCargoes(i_act_cargo):=0;
			}
		}
		Procedure pr_CloseDataOverView {
			Body: {
				!Close Overview dataset
				ui::sp_systemWorkflowFoldingStates(1, 4, 'openclose') := "close";
			}
		}
		DeclarationSection Declaration_Master_Active_Page {
			Set s_MasterLocations {
				SubsetOf: s_locations;
				Index: i_ActiveLoc, i_ActiveLoc2;
				Definition: {
					!{i_Loc | ep_LoadingPortsCargo(i_ActiveCargo)}
					{i_Loc|exists(i_act_cargo | i_Loc = ep_LoadingPortsCargo(i_act_cargo))}+
					{i_Loc|exists(i_act_cargo | i_Loc = ep_DeliveringPortsCargo(i_act_cargo))}+
					{i_Loc|exists(i_act_vessel | i_Loc = ep_originPortOfVessel(i_act_vessel))}
					!Als de locatie gebruikt wordt bij de loading en delevering ports
				}
			}
			Set s_MasterTypeCost {
				SubsetOf: s_costTypes;
				Index: i_ActiveCostType;
				Definition: {
					{i_ct | bp_activeCostsForCargoes(i_ct)}
				}
			}
		}
		DeclarationSection Declaration_Mapping_CargoData {
			Set s_SortOfPortsCargo {
				Index: i_SortOfPort;
				Parameter: ep_SortOfPortsCargo;
				Definition: pr_LegendCargoViz;
			}
			Set s_SelectedCargoesInMap {
				SubsetOf: s_def_activeCargoes;
				Index: i_selectedCargo;
				Definition: {
					{i_act_cargo | ui::p_AllocatedCargoes(i_act_cargo)}
				}
			}
			StringParameter sp_PortsCargoPageAnnotation {
				IndexDomain: i_Loc;
				Definition: {
					if (i_Loc in ui::s_SubsetCargoLoadingPorts) and (i_loc in ui::s_SubsetCargoDeleveringPorts) then
					    "LoadAndDelPort"    
					elseif i_Loc in ui::s_SubsetCargoLoadingPorts then
					    "LoadPort"
					else
					    "DelPort"
					endif;
				}
			}
			Set s_SubsetVesselPortOrigin {
				SubsetOf: s_locations;
				Index: i_LocVesselPort;
				Definition: {
					{i_Loc| exists(i_act_vessel | i_Loc = ep_originPortOfVessel(i_act_vessel))}
				}
			}
		}
		DeclarationSection Declaration_Mapping_LocAndVessel_Data {
			StringParameter sp_LocationIc {
				IndexDomain: i_Loc;
				Definition: "aimms-location4";
			}
			StringParameter sp_VesselIcons {
				IndexDomain: i_Loc;
				Definition: "aimms-ship";
			}
			Parameter p_SizeIconLocation {
				IndexDomain: i_Loc;
				Definition: 10;
			}
		}
		DeclarationSection Declaration_Results_page {
			Set s_SubsetRoutes {
				SubsetOf: s_allocatedRoutes;
				Index: i_selectedRoute;
				Definition: {
					{i_allcRoute | p_Allocatedroutes(i_allcRoute)}
				}
				Comment: "Used by selecting routes in resultpage";
			}
			Parameter p_VesselsNotUsed {
				IndexDomain: i_act_vessel;
				Range: binary;
				Definition: mm::v_IdleVessel(i_act_vessel);
				webui::FlagsIdentifier: sp_ReadsOnly;
			}
			Parameter p_LoadingTimeCargoRoute {
				IndexDomain: (i_act_cargo,i_route);
				Unit: day;
				webui::FlagsIdentifier: sp_ReadsOnly;
			}
			StringParameter sp_LoadingTimeCargoRoute {
				IndexDomain: i_act_cargo;
				webui::FlagsIdentifier: sp_ReadsOnly;
			}
			Parameter p_DeleveringTimeCargoRoute {
				IndexDomain: (i_act_cargo,i_route) | p_CargoesOnRouteBin(i_route,i_act_cargo);
				Unit: day;
				Definition: (p_LoadingTimeCargoRoute(i_act_cargo, i_route) + p_DistanceBetweenLocations(ep_LoadingPortsCargo(i_act_cargo), ep_DeliveringPortsCargo(i_act_cargo)));
				webui::FlagsIdentifier: sp_ReadsOnly;
			}
			StringParameter sp_DeleveringTimeCargoRoute {
				IndexDomain: i_act_cargo;
				webui::FlagsIdentifier: sp_ReadsOnly;
			}
			StringParameter sp_ReadsOnly {
				Definition: "readonly";
			}
		}
		DeclarationSection Declaration_Mapping_Visualisation_Route {
			Set s_CargoesOnSelectedRoutes {
				SubsetOf: s_cargoes;
				Index: i_SelectedCargoOnRoute;
				Definition: {
					{i_act_cargo|exists(i_selectedRoute|p_CargoesOnRouteBin(i_selectedRoute, i_act_cargo))}
				}
				Comment: "{i_ActiveCargo|exists(i_selectedRoute|p_CargoesOnRouteBin(i_selectedRoute, i_ActiveCargo)}";
			}
			Set s_VesselOnSelectedRoutes {
				SubsetOf: s_vessels;
				Index: i_ActiveVesselUsed;
				Definition: {
					{i_act_vessel | exists(i_selectedRoute|ep_VesselOnRoute(i_selectedRoute)=i_act_vessel)}
				}
			}
			Set s_SubsetCargoLoadingRoutePorts {
				SubsetOf: s_locations;
				Index: i_CargLocLoadRoute;
				Definition: {
					{i_Loc|exists(i_SelectedCargoOnRoute | i_Loc = ep_LoadingPortsCargo(i_SelectedCargoOnRoute))}
				}
			}
			Set s_SubsetCargoDeliveringRoutePorts {
				SubsetOf: s_locations;
				Index: i_CargLocDelRoute;
				Definition: {
					{i_Loc|exists(i_SelectedCargoOnRoute | i_Loc = ep_DeliveringPortsCargo(i_SelectedCargoOnRoute))}
				}
			}
			Set s_SubsetVesselLoadingPorts {
				SubsetOf: s_locations;
				Index: i_VesselPortOrigin;
				Definition: {
					!{i_Loc|exists(i_ActiveVessel | i_Loc = ep_LoadingPortsVessel(i_ActiveVessel)| v_IdleVessel(i_ActiveVessel)<1)}
					{i_Loc|exists(i_ActiveVesselUsed | i_Loc = ep_originPortOfVessel(i_ActiveVesselUsed))}
				}
			}
			StringParameter sp_PortsVisualisationPageAnnotation {
				IndexDomain: i_Loc;
				Definition: {
					if (i_Loc in s_SubsetCargoLoadingRoutePorts) and (i_loc in s_SubsetCargoDeliveringRoutePorts) and 
					    (i_Loc in s_SubsetVesselLoadingPorts) then
					    "AllThreePorts"
					elseif (i_Loc in s_SubsetVesselLoadingPorts) and (i_loc in s_SubsetCargoDeliveringRoutePorts) then
					    "VesAndDelPort"
					elseif (i_Loc in s_SubsetVesselLoadingPorts) and (i_loc in s_SubsetCargoLoadingRoutePorts) then
					    "VesAndLoadPort"
					elseif (i_Loc in s_SubsetVesselLoadingPorts) and (i_loc in s_SubsetCargoDeliveringRoutePorts) then
					    "LoadAndDelPort"    
					elseif i_Loc in s_SubsetVesselLoadingPorts then
					    "VesPort"
					elseif i_Loc in ui::s_SubsetCargoLoadingPorts then
					    "LoadPort"
					else
					    "DelPort"
					endif;
				}
			}
			Set s_SortPortsRouteVis {
				Index: i_SortRouteVis;
				Parameter: ep_SortPortsRouteVis;
				Definition: pr_LegendRouteViz;
			}
			Parameter p_SizeRoutesLocation {
				IndexDomain: i_Loc;
				Definition: 1;
				webui::AnnotationsIdentifier: sp_PortsVisualisationPageAnnotation(i_Loc);
			}
		}
		DeclarationSection Declaration_GanttChart {
			Parameter p_DurationCargoOnRoute {
				IndexDomain: (i_act_cargo,i_route);
				Unit: day;
				Definition: (p_DeleveringTimeCargoRoute(i_act_cargo, i_route)-p_LoadingTimeCargoRoute(i_act_cargo, i_route))*24;
			}
			Parameter p_LoadingTimeCargoRouteInHours {
				IndexDomain: (i_act_cargo,i_route);
				Unit: day;
				Definition: p_LoadingTimeCargoRoute(i_act_cargo, i_route)*24;
			}
			StringParameter sp_StartGanttChart {
				Definition: formatstring("%e",ep_StartHorizonDate);
			}
		}
		Section Arcs {
			Procedure pr_CalculateAllArcs {
				Body: {
					empty p_mapArcPerCargo, p_mapArcPerCargoConsideringPickupDropoff,p_FromBerthToCargoTest,p_FromBerthToCargo,p_MapArcPerCargoLocations,sp_RouteInformation;
					sp_RouteInformation(i_Loc,i_loc_from):=FormatString("%e <br>to<br>%s",i_Loc,i_loc_from);
					
					for i_selectedRoute do
					
					    !Calculate location from berth to the location of the loading of the first cargo
					    p_FromBerthToCargoTest(ep_originPortOfVessel(ep_VesselOnRoute(i_selectedRoute)),ep_LoadingPortsCargo(first(i_act_cargo|p_CargoesOnRoute(i_selectedRoute,i_act_cargo)=1))):=1;
					    ep_allcRoute := i_selectedRoute;
					    s_loc_currentCargos := {i_act_cargo | p_CargoesOnRoute(ep_allcRoute, i_act_cargo)};
					    sp_RouteInformation(ep_originPortOfVessel(ep_VesselOnRoute(i_selectedRoute)),ep_LoadingPortsCargo(first(i_act_cargo|p_CargoesOnRoute(i_selectedRoute,i_act_cargo)=1)))+="<br>Picking up cargo: "+first(i_act_cargo|p_CargoesOnRoute(i_selectedRoute,i_act_cargo)=1);
					
					    for i_loc_cargo | p_CargoesOnRoute(i_selectedRoute, i_loc_cargo) do 
					    	!Calculate location of the loading and delivering of the cargo
					        p_MapArcPerCargoLocations(ep_LoadingPortsCargo(i_loc_cargo), ep_DeliveringPortsCargo(i_loc_cargo)) := 1;
						sp_RouteInformation(ep_LoadingPortsCargo(i_loc_cargo), ep_DeliveringPortsCargo(i_loc_cargo))+="<br>Deliver cargo: "+i_loc_cargo;
					
						!Calculate the location from delivering to the loading point of the new cargo
					        for i_loc_cargo1 | 
					                p_CargoesOnRoute(i_selectedRoute, i_loc_cargo) < p_CargoesOnRoute(i_selectedRoute, i_loc_cargo1) 
					                and i_loc_cargo1 <> i_loc_cargo do
					
					            p_mapArcPerCargo(i_selectedRoute, i_loc_cargo, i_loc_cargo1) := 1;
					
					            if ep_DeliveringPortsCargo(i_loc_cargo) = ep_LoadingPortsCargo(i_loc_cargo1) then
					                p_MapArcPerCargoLocations(ep_LoadingPortsCargo(i_loc_cargo1), ep_DeliveringPortsCargo(i_loc_cargo1)) := 1;
					                p_loc_aux := 1;
					            else
					                p_MapArcPerCargoLocations(ep_DeliveringPortsCargo(i_loc_cargo), ep_LoadingPortsCargo(i_loc_cargo1)) := 1;
					                p_MapArcPerCargoLocations(ep_LoadingPortsCargo(i_loc_cargo1), ep_DeliveringPortsCargo(i_loc_cargo1)) := 1;
					
					                sp_RouteInformation(ep_DeliveringPortsCargo(i_loc_cargo), ep_LoadingPortsCargo(i_loc_cargo1))+="<br>Picking up cargo: "+i_loc_cargo1;
					
					            endif;
					
					            break;
					        endfor;
					    endfor;
					endfor;
				}
				Set s_loc_currentCargos {
					SubsetOf: s_cargoes;
					Index: i_loc_cargo, i_loc_cargo1;
					OrderBy: p_CargoesOnRoute(ep_allcRoute, i_cargo);
				}
				Parameter p_loc_aux;
			}
			DeclarationSection Declaration_Arcs {
				StringParameter sp_CargoLoadingtoCargoDelivery {
					IndexDomain: (i_ActiveLoc,i_ActiveLoc2);
					Definition: {
						FormatString("%e <br>to<br>%s <br> %n Days",i_ActiveLoc,i_ActiveLoc2,p_DeliveringToLoadingports(i_ActiveLoc,i_ActiveLoc2));
					}
				}
				StringParameter sp_CargoRoute {
					IndexDomain: (i_ActiveLoc,i_ActiveLoc2);
					Definition: {
						FormatString("%e <br>to<br>%s",i_ActiveLoc,i_ActiveLoc2);
					}
				}
				StringParameter sp_RouteInformation {
					IndexDomain: (i_loc,i_loc_from);
				}
				ElementParameter ep_AllocatedRoute {
					IndexDomain: i_allcRoute;
					Range: s_allocatedRoutes;
				}
				Parameter p_FromToDestination {
					IndexDomain: i_route;
				}
				Parameter p_FromBerthToCargo {
					IndexDomain: (i_allcRoute,i_loc,i_loc_from);
				}
				Parameter p_FromBerthToCargoTest {
					IndexDomain: (i_Loc,i_loc_from);
					webui::TooltipIdentifier: sp_RouteInformation( i_Loc, i_loc_from );
				}
				Parameter p_MapArcPerCargoLocations {
					IndexDomain: (i_Loc,i_loc_from);
					webui::TooltipIdentifier: sp_RouteInformation;
				}
				Parameter p_mapArcPerCargo {
					IndexDomain: (i_allcRoute,i_Cargo,i_cargo_aux);
					Range: binary;
				}
				Parameter p_mapArcPerCargoConsideringPickupDropoff {
					IndexDomain: (i_allcRoute,i_Loc,i_loc_from);
					Range: binary;
				}
				Parameter p_DeliveringToLoadingports {
					IndexDomain: (i_ActiveLoc,i_ActiveLoc2);
					Unit: day;
					Definition: {
						!p_DistanceBetweenLocations(i_loc,i_loc_aux)|exists(i_cargo|(i_loc=ep_LoadingPortsCargo(i_cargo)and i_loc_aux=ep_DeliveringPortsCargo(i_cargo)))
						p_DistanceBetweenLocations(i_ActiveLoc,i_ActiveLoc2)$exists(i_act_cargo|(i_ActiveLoc=ep_LoadingPortsCargo(i_act_cargo)and i_ActiveLoc2=ep_DeliveringPortsCargo(i_act_cargo)))
					}
					webui::TooltipIdentifier: sp_CargoRoute;
				}
			}
		}
	}
	Procedure PostMainInitialization {
		Comment: {
			"Add initialization statements here that require that the libraries are already initialized properly,
			or add statements that require the Data Management module to be initialized."
		}
	}
	Procedure MainInitialization {
		Body: {
			!Random see
		}
		Comment: "Add initialization statements here that do NOT require any library being initialized already.";
	}
	Procedure MainExecution {
		Body: {
			solve mm::mp_SchedullingVessels;
			ui::sp_systemWorkFlowSteps(1,8,'workflowPageState') := "active";
			ui::sp_systemWorkFlowSteps(1,9,'workflowPageState') := "active";
			
			!Changes statusbar
			ui::sp_systemStatusBar(3,'icon') := "aimms-checkmark-circle";
			ui::sp_systemStatusBar(3,'color') := "Green";
			ui::sp_systemStatusBar(3,'tooltip') := "The model has been solved.";
			
			!Active Routes
			p_Allocatedroutes(i_allcRoute) := 1;
			
			!Determine time cargoes
			pr_determineLoadingAndDelivering;
			
			!Na het oplossen moeten sommige waarden omgezet worden naar datums
			pr_ConvertToDate;
			
			!Get the arcs
			pr_CalculateAllArcs;
		}
	}
	Procedure PreMainTermination {
		Body: {
			return DataManagementExit();
		}
		Comment: {
			"Add termination statements here that require all libraries to be still alive.
			Return 1 if you allow the termination sequence to continue.
			Return 0 if you want to cancel the termination sequence."
		}
	}
	Procedure MainTermination {
		Body: {
			return 1;
		}
		Comment: {
			"Add termination statements here that do not require all libraries to be still alive.
			Return 1 to allow the termination sequence to continue.
			Return 0 if you want to cancel the termination sequence.
			It is recommended to only use the procedure PreMainTermination to cancel the termination sequence and let this procedure always return 1."
		}
	}
}
