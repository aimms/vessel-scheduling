## ams_version=1.0

Model Main_Vessel_Schedule {
	Section Data_Model {
		Section Quantities_and_Units {
			Comment: {
				"This section contains all the units and quantities that are added automatically by AIMMS.
				It is recommended to declare all your quantities here."
			}
			Quantity SI_Time_Duration {
				BaseUnit: s;
				Conversions: {
					day->s : #-># * 86400,
					minute->s : #-># * 60
				}
				Comment: {
					"Expresses the value for the duration of periods.
					
					The unit s has been added automatically because it is a required unit for AimmsWebUI.
					
					The unit minute has been added automatically because it is a required unit for AimmsWebUI.
					
					The unit minute has been added automatically because it is a required unit for AimmsWebUI."
				}
			}
			Quantity Q_Currency {
				BaseUnit: $;
			}
		}
		Section Calendars {
			Calendar cal_days {
				Index: i_day;
				Unit: day;
				BeginDate: sp_def_beginDate;
				EndDate: sp_def_endDate;
				TimeslotFormat: "%c%y-%m-%d";
			}
			ElementParameter ep_startHorizonDate {
				Range: cal_days;
			}
			StringParameter sp_def_beginDate {
				Definition: "2000-01-01";
			}
			StringParameter sp_def_endDate {
				Definition: "2099-12-31";
			}
		}
		Section Cargoes {
			Set s_cargoes {
				Index: i_cargo_aux;
				Parameter: ep_cargo;
			}
			Index i_cargo {
				Range: s_cargoes;
				dex::ColumnName: Cargo;
			}
			Set s_def_activeCargoes {
				SubsetOf: s_cargoes;
				Index: i_act_cargo, i_act_cargo_aux;
				Definition: {
					{i_cargo | bp_activeCargoes(i_cargo)}
				}
			}
			Parameter bp_activeCargoes {
				IndexDomain: i_cargo;
				Range: binary;
				InitialData: 1;
			}
			Parameter p_spotCostVessel {
				IndexDomain: i_cargo;
				Unit: $;
				Comment: "todo: what this is?";
				dex::ColumnName: Spotcost on Vessel;
				dex::Dataset: Import;
				dex::TableName: CargoData;
			}
			ElementParameter ep_minTimeWindow {
				IndexDomain: i_cargo;
				Range: cal_days;
				dex::ColumnName: Minimum Loading Time;
				dex::Dataset: Import;
				dex::TableName: CargoData;
			}
			ElementParameter ep_maxTimeWindow {
				IndexDomain: i_cargo;
				Range: cal_days;
				Comment: "todo: what this is?";
				dex::ColumnName: Maximum Loading Time;
				dex::Dataset: Import;
				dex::TableName: CargoData;
			}
			ElementParameter ep_loadingPortsCargo {
				IndexDomain: i_cargo;
				Range: s_locations;
				Comment: "todo: not on screen";
				dex::ColumnName: Loading Port;
				dex::Dataset: Import;
				dex::TableName: CargoData;
			}
			ElementParameter ep_deliveringPortsCargo {
				IndexDomain: i_cargo;
				Range: s_locations;
				Comment: "todo: not on screen";
				dex::ColumnName: Delevering Port;
				dex::Dataset: Import;
				dex::TableName: CargoData;
			}
			Parameter p_cargoCost {
				IndexDomain: (i_cargo,i_ct) | bp_activeCostsForCargoes(i_ct);
				Range: free;
				Unit: $;
				dex::ColumnName: Type Costs;
				dex::Dataset: Import;
				dex::TableName: CargoCosts;
			}
			Set s_def_loadingPorts {
				SubsetOf: s_locations;
				Index: i_loc_load;
				Definition: {
					{i_loc | exists(i_cargo | i_loc = ep_loadingPortsCargo(i_cargo))}
				}
			}
			Set s_def_deleveringPorts {
				SubsetOf: s_locations;
				Index: i_loc_del;
				Definition: {
					{i_loc | exists(i_cargo | i_loc = ep_deliveringPortsCargo(i_cargo))}
				}
			}
			Set s_def_vesselOriginPorts {
				SubsetOf: s_locations;
				Index: i_loc_ves;
				Definition: {
					{i_loc | exists(i_act_vessel | i_loc = ep_originPortOfVessel(i_act_vessel))}
				}
			}
			Parameter p_def_minTimeWindow {
				IndexDomain: i_cargo;
				Unit: day;
				Definition: StringToMoment("%c%y-%m-%d", [day], ep_startHorizonDate, ep_minTimeWindow(i_cargo));
			}
			Parameter p_def_maxTimeWindow {
				IndexDomain: i_cargo;
				Unit: day;
				Definition: StringToMoment("%c%y-%m-%d", [day], ep_startHorizonDate, ep_maxTimeWindow(i_cargo));
			}
		}
		Section Vessels {
			Set s_vessels {
				Parameter: ep_vessel;
			}
			Index i_vessel {
				Range: s_vessels;
				dex::ColumnName: Vessel;
			}
			Set s_def_activeVessels {
				SubsetOf: s_vessels;
				Index: i_act_vessel;
				Definition: {
					{i_vessel | bp_activeVessels(i_vessel)}
				}
			}
			Parameter bp_activeVessels {
				IndexDomain: i_vessel;
				Range: binary;
				InitialData: 1;
			}
			ElementParameter ep_originPortOfVessel {
				IndexDomain: i_vessel;
				Range: s_locations;
				dex::ColumnName: Port of Origin;
				dex::Dataset: Import;
				dex::TableName: VesselData;
			}
			Parameter p_def_idleCostVesselNotUsed {
				IndexDomain: i_vessel;
				Unit: $;
				Definition: {
					! Location vessel multiply max time horizon
					p_IdleCostLocation(ep_originPortOfVessel(i_vessel)) 
					* max(i_cargo, p_def_maxTimeWindow(i_cargo));
				}
				Comment: "todo: check if makes sense";
			}
			Parameter p_vesselCostDay {
				IndexDomain: (i_vessel,i_ct) | bp_activeCostsForVessels(i_ct);
				Unit: $/day;
				Comment: {
					"! Fuel usage per day is 63000 gallons = 238000 liter -> 238000/100000 * â‚¬601 = 1433"
				}
				dex::ColumnName: DailyCost;
				dex::Dataset: Import;
				dex::TableName: VesselCosts;
			}
		}
		Section Cost_Types {
			Set s_costTypes {
				Parameter: ep_costType;
			}
			Index i_ct {
				Range: s_costTypes;
				dex::ColumnName: Cost Type;
			}
			Set s_def_costTypesForCargoes {
				SubsetOf: s_costTypes;
				Index: i_ct_cargo;
				Definition: {
					{i_ct | bp_activeCostsForCargoes(i_ct)}
				}
			}
			Set s_def_costsForCargoes {
				SubsetOf: s_costTypes;
				Index: i_act_ct_cargo;
				Definition: {
					{i_ct | bp_activeCostsForCargoes(i_ct)}
				}
			}
			Parameter bp_activeCostsForCargoes {
				IndexDomain: i_ct;
				Range: binary;
				dex::ColumnName: Cargoes;
				dex::Dataset: Import;
				dex::TableName: Type Cost Group;
			}
			Set s_def_costTypesForVessels {
				SubsetOf: s_costTypes;
				Index: i_ct_vessel;
				Definition: {
					{i_ct | bp_activeCostsForVessels(i_ct)}
				}
			}
			Parameter bp_activeCostsForVessels {
				IndexDomain: i_ct;
				Range: binary;
				dex::ColumnName: Vessel;
				dex::Dataset: Import;
				dex::TableName: Type Cost Group;
			}
			Set s_def_costTypesForLocations {
				SubsetOf: s_costTypes;
				Index: i_ct_loc;
				Definition: {
					{i_ct | bp_activeCostsForLocations(i_ct)}
				}
			}
			Parameter bp_activeCostsForLocations {
				IndexDomain: i_ct;
				Range: binary;
				dex::ColumnName: Location;
				dex::Dataset: Import;
				dex::TableName: Type Cost Group;
			}
		}
		Section Locations {
			Set s_locations {
				Parameter: ep_location;
			}
			Index i_loc {
				Range: s_locations;
				dex::ColumnName: Location;
			}
			Index i_loc_from {
				Range: s_locations;
				dex::ColumnName: Location (From);
			}
			Index i_loc_to {
				Range: s_locations;
				dex::ColumnName: Location (To);
			}
			Set s_def_activeLocations {
				SubsetOf: s_locations;
				Index: i_act_loc;
				Definition: {
					{i_loc | bp_activeLocations(i_loc)}
				}
			}
			Parameter bp_activeLocations {
				IndexDomain: i_loc;
				Range: binary;
				InitialData: 1;
			}
			Parameter p_latitude {
				IndexDomain: i_loc;
				dex::ColumnName: Latitude;
				dex::Dataset: Import;
				dex::TableName: LocationData;
			}
			Parameter p_longitude {
				IndexDomain: i_loc;
				dex::ColumnName: Longitude;
				dex::Dataset: Import;
				dex::TableName: LocationData;
			}
			Parameter p_idleCostLocation {
				IndexDomain: i_loc;
				Unit: $/day;
				dex::ColumnName: Idle Cost;
				dex::Dataset: Import;
				dex::TableName: LocationData;
			}
			Parameter p_locationCost {
				IndexDomain: (i_loc,i_ct) | bp_activeCostsForLocations(i_ct);
				Unit: $;
				Definition: {
					!Hoe wordt dit in de webui teruggeven
					!sum(i_CostType |
				}
				dex::ColumnName: Costs;
				dex::Dataset: Import;
				dex::TableName: LocationCosts;
			}
			Parameter p_distanceBetweenLocations {
				IndexDomain: (i_loc_from,i_loc_to)| i_loc_from <> i_loc_to;
				Unit: day;
				dex::ColumnName: DeleveringLocation;
				dex::Dataset: Import;
				dex::TableName: DistanceBetweenLocations;
			}
		}
		Section Routes {
			Set s_calc_feasibleRoutes {
				Index: i_route;
				Parameter: ep_route;
			}
			ElementParameter ep_calc_vesselOnRoute {
				IndexDomain: i_route;
				Range: s_def_activeVessels;
				webui::FlagsIdentifier: ui::sp_def_readOnly;
			}
			Parameter p_calc_totalRouteLocationCost {
				IndexDomain: i_route;
				Unit: $;
			}
			Parameter p_calc_totalRouteCargoCost {
				IndexDomain: i_route;
				Unit: $;
			}
			Parameter p_calc_loadingTimeCargoRoute {
				IndexDomain: (i_act_cargo,i_route);
				Unit: day;
				webui::FlagsIdentifier: ui::sp_def_readOnly;
			}
			Parameter p_calc_cargoesOnRoute {
				IndexDomain: (i_route,i_cargo);
				Range: nonnegative;
			}
			Parameter p_calc_totalDaysTravel {
				IndexDomain: i_route;
				Unit: day;
				webui::FlagsIdentifier: ui::sp_def_readOnly;
			}
			Parameter p_calc_totalRouteIdleCost {
				IndexDomain: (i_route);
				Unit: $;
			}
			StringParameter sp_loc_cargoesOnRoute {
				IndexDomain: i_route;
				webui::FlagsIdentifier: ui::sp_def_readOnly;
			}
			Parameter p_loc_travelTimeCargoes {
				IndexDomain: (i_cargo,i_cargo_aux) | (i_cargo<>i_cargo_aux);
				Unit: day;
				Definition: {
					!13,5 knots = 25 km/h
					!1 day = 600km
					p_DistanceBetweenLocations(ep_LoadingPortsCargo(i_cargo),ep_DeliveringPortsCargo(i_cargo)) +
					p_DistanceBetweenLocations(ep_DeliveringPortsCargo(i_cargo),ep_LoadingPortsCargo(i_cargo_aux))
				}
			}
			ElementParameter ep_loc_lastCargoFromRoute {
				IndexDomain: i_route;
				Range: s_cargoes;
			}
			Parameter p_loc_lastLoadArrivalTime {
				IndexDomain: i_route;
				Unit: day;
			}
			Parameter p_loc_lastDeliverArrivalTime {
				IndexDomain: i_route;
				Unit: day;
			}
			Parameter p_loc_quantityOfCargos {
				IndexDomain: i_route;
			}
			Parameter p_def_totalRouteMovementCost {
				IndexDomain: i_route;
				Unit: $;
				Definition: {
					p_calc_totalDaysTravel(i_route) 
					* sum(i_ct, p_vesselCostDay(ep_calc_vesselOnRoute(i_route), i_ct))
				}
			}
			Parameter bp_def_cargoesOnRoute {
				IndexDomain: (i_route,i_cargo);
				Range: binary;
				Definition: 1 $ p_calc_cargoesOnRoute(i_route, i_cargo);
			}
			Parameter p_def_deleveringTimeCargoRoute {
				IndexDomain: (i_act_cargo,i_route) | bp_def_cargoesOnRoute(i_route,i_act_cargo);
				Unit: day;
				Definition: {
					(p_calc_loadingTimeCargoRoute(i_act_cargo, i_route) 
					+ p_distanceBetweenLocations(ep_loadingPortsCargo(i_act_cargo), ep_deliveringPortsCargo(i_act_cargo)))
				}
				webui::FlagsIdentifier: ui::sp_def_readOnly;
			}
			Procedure pr_calculateRoutesAndCost {
				Body: {
					empty s_calc_feasibleRoutes;
					empty p_calc_cargoesOnRoute;
					
					!Assumption: when a vessel is used, and the time horizon starts, 
					!the vessel will always directly move to the loading port of the cargo.
					
					for i_act_vessel do
					
					    p_loc_loopCount := 1;
					
					    for i_act_cargo do
					
					        SetElementAdd(s_calc_feasibleRoutes, ep_route, i_act_vessel + "_" + i_act_cargo);
					
					        !Cannot come earlier then arrival time
					        p_loc_lastLoadArrivalTime(ep_route) |
					                (p_distanceBetweenLocations(ep_originPortOfVessel(i_act_vessel), ep_loadingPortsCargo(i_act_cargo)) 
					                <= p_def_minTimeWindow(i_act_cargo))
					        :=  p_def_minTimeWindow(i_act_cargo);
					
					        p_loc_lastLoadArrivalTime(ep_route) |
					                (p_def_minTimeWindow(i_act_cargo) 
					                <= p_distanceBetweenLocations(ep_originPortOfVessel(i_act_vessel), ep_loadingPortsCargo(i_act_cargo)) 
					                <= p_def_maxTimeWindow(i_act_cargo))
					        :=  p_distanceBetweenLocations(ep_originPortOfVessel(i_act_vessel), ep_loadingPortsCargo(i_act_cargo));
					
					        ep_loc_lastCargoFromRoute(ep_route) := i_act_cargo;
					        ep_calc_vesselOnRoute(ep_route) := i_act_vessel;
					        p_calc_cargoesOnRoute(ep_route, i_act_cargo) := 1;
					        p_loc_quantityOfCargos(ep_route) := 1;
					
					        !Loading and delivering time
					        p_calc_loadingTimeCargoRoute(i_act_cargo, ep_route) |
					                (p_distanceBetweenLocations(ep_originPortOfVessel(i_act_vessel), ep_loadingPortsCargo(i_act_cargo)) 
					                <= p_def_minTimeWindow(i_act_cargo))
					        :=  p_def_minTimeWindow(i_act_cargo);
					
					        p_calc_loadingTimeCargoRoute(i_act_cargo, ep_route) |
					                (p_def_minTimeWindow(i_act_cargo) 
					                <= p_distanceBetweenLocations(ep_originPortOfVessel(i_act_vessel), ep_loadingPortsCargo(i_act_cargo)) 
					                <= p_def_maxTimeWindow(i_act_cargo))
					        :=  p_distanceBetweenLocations(ep_originPortOfVessel(i_act_vessel), ep_LoadingPortsCargo(i_act_cargo));
					
					        !Add cargoes to route
					        sp_loc_cargoesOnRoute(ep_route) := i_act_cargo;
					
					        !Extra deliver arrival time
					        p_loc_lastDeliverArrivalTime(ep_route)
					        :=  p_loc_lastLoadArrivalTime(ep_route) 
					            + p_distanceBetweenLocations(ep_loadingPortsCargo(i_act_cargo), ep_deliveringPortsCargo(i_act_cargo));
					
					        !Idle cost per route first cargo
					        p_calc_totalRouteIdleCost(ep_route) 
					        :=  p_idleCostLocation(ep_loadingPortsCargo(i_act_cargo)) 
					            * (p_def_minTimeWindow(i_act_cargo) 
					                - p_distanceBetweenLocations(ep_originPortOfVessel(i_act_vessel), ep_loadingPortsCargo(i_act_cargo)));
					
					        !Cost for first movement
					        p_calc_totalDaysTravel(ep_route) 
					        :=  p_distanceBetweenLocations(ep_originPortOfVessel(i_act_vessel), ep_loadingPortsCargo(i_act_cargo))
					            + p_distanceBetweenLocations(ep_loadingPortsCargo(i_act_cargo), ep_deliveringPortsCargo(i_act_cargo));
					
					        !Cost for first location
					        p_calc_totalRouteLocationCost(ep_route) 
					        :=  sum(i_act_ct_cargo, 
					                p_locationCost(ep_loadingPortsCargo(i_act_cargo), i_act_ct_cargo)
					                + p_locationCost(ep_deliveringPortsCargo(i_act_cargo), i_act_ct_cargo));
					
					        !Cost for first cargo
					        p_calc_totalRouteCargoCost(ep_route) := sum(i_act_ct_cargo, p_cargoCost(i_act_cargo, i_act_ct_cargo));
					
					    endfor;
					
					    repeat 
					
					        !Select all routes that are equal to the loop count and to the correct vessel
					        s_loc_subRoutes 
					        :=  {i_route | 
					                    p_loc_quantityOfCargos(i_route) = p_loc_loopCount 
					                    and ep_calc_vesselOnRoute(i_route) = i_act_vessel}; 
					
					        !Statement to break out of the loop
					        if card(s_loc_subRoutes) = 0 then
					            break;
					        endif;
					
					        for i_loc_sub_route do
					
					            !Only cargoes that are not on the route yet
					            for i_act_cargo | p_calc_cargoesOnRoute(i_loc_sub_route, i_act_cargo) = 0 do  
					
					                if p_loc_travelTimeCargoes(ep_loc_lastCargoFromRoute(i_loc_sub_route), i_act_cargo) + p_loc_lastLoadArrivalTime(i_loc_sub_route) 
					                    <= p_def_minTimeWindow(i_act_cargo) then
					
					                    SetElementAdd(s_calc_feasibleRoutes, ep_route, i_loc_sub_route + "_" + i_act_cargo);
					
					                    p_loc_lastLoadArrivalTime(ep_route) := p_def_minTimeWindow(i_act_cargo);
					                    ep_loc_lastCargoFromRoute(ep_route) := i_act_cargo;
					                    ep_calc_vesselOnRoute(ep_route) := i_act_vessel;
					                    p_loc_quantityOfCargos(ep_route) := p_loc_loopCount + 1;
					                    p_calc_cargoesOnRoute(ep_route, i_act_cargo_aux) := p_calc_cargoesOnRoute(i_loc_sub_route, i_act_cargo_aux);
					                    p_calc_cargoesOnRoute(ep_route, i_act_cargo) := p_loc_quantityOfCargos(ep_route);
					
					                    !Loading and delivering time
					                    p_calc_loadingTimeCargoRoute(i_act_cargo_aux, ep_route) :=  p_calc_loadingTimeCargoRoute(i_act_cargo_aux, i_loc_sub_route);
					                    p_calc_loadingTimeCargoRoute(i_act_cargo, ep_route) :=  p_def_minTimeWindow(i_act_cargo);
					
					                    !Add cargoes to route
					                    sp_loc_cargoesOnRoute(ep_route) := sp_loc_cargoesOnRoute(i_loc_sub_route) + "," + i_act_cargo;
					
					                    !Extra deliver arrival time
					                    p_loc_lastDeliverArrivalTime(ep_route) 
					                    :=  p_loc_lastLoadArrivalTime(ep_route) 
					                        + p_distanceBetweenLocations(ep_loadingPortsCargo(i_act_cargo), ep_deliveringPortsCargo(i_act_cargo));
					
					                    !Idle cost per route next cargoes
					                    p_calc_totalRouteIdleCost(ep_route) 
					                    :=  p_calc_totalRouteIdleCost(i_loc_sub_route) 
					                        +  p_idleCostLocation(ep_loadingPortsCargo(i_act_cargo)) 
					                        * (p_def_minTimeWindow(i_act_cargo) 
					                            - (p_loc_travelTimeCargoes(ep_loc_lastCargoFromRoute(i_loc_sub_route), i_act_cargo) 
					                                + p_loc_lastLoadArrivalTime(i_loc_sub_route)));
					
					                    !Cost for the other movements
					                    p_calc_totalDaysTravel(ep_route) 
					                    :=  p_calc_totalDaysTravel(i_loc_sub_route)
					                        + p_distanceBetweenLocations(ep_deliveringPortsCargo(ep_loc_lastCargoFromRoute(ep_route)), ep_loadingPortsCargo(i_act_cargo))
					                        + p_distanceBetweenLocations(ep_loadingPortsCargo(i_act_cargo), ep_deliveringPortsCargo(i_act_cargo));
					
					                    !Cost for the other locations
					                    if ep_deliveringPortsCargo(ep_loc_lastCargoFromRoute(i_loc_sub_route)) <> ep_loadingPortsCargo(i_act_cargo) then
					                        p_calc_totalRouteLocationCost(ep_route) 
					                        :=  p_calc_totalRouteLocationCost(i_loc_sub_route)
					                            + sum(i_act_ct_cargo, 
					                                    p_locationCost(ep_loadingPortsCargo(i_act_cargo), i_act_ct_cargo) 
					                                    + p_locationCost(ep_deliveringPortsCargo(i_act_cargo), i_act_ct_cargo));
					                    else 
					                        p_calc_totalRouteLocationCost(ep_route) 
					                        :=  p_calc_totalRouteLocationCost(i_loc_sub_route)
					                            + sum(i_act_ct_cargo, p_locationCost(ep_deliveringPortsCargo(i_act_cargo), i_act_ct_cargo));                                
					                    endif;                
					
					                    !Cost for the other cargoes
					                    p_calc_totalRouteCargoCost(ep_route) 
					                    :=  p_calc_totalRouteCargoCost(i_loc_sub_route)
					                        + sum(i_act_ct_cargo, p_cargoCost(i_act_cargo, i_act_ct_cargo));
					
					                elseif p_def_minTimeWindow(i_act_cargo) 
					                        <= p_loc_travelTimeCargoes(ep_loc_lastCargoFromRoute(i_loc_sub_route), i_act_cargo) 
					                            + p_loc_lastLoadArrivalTime(i_loc_sub_route) 
					                        <= p_def_maxTimeWindow(i_act_cargo) then
					
					                    SetElementAdd(s_calc_feasibleRoutes, ep_route, i_loc_sub_route + "_" + i_act_cargo);
					                    p_loc_lastLoadArrivalTime(ep_route) := p_loc_travelTimeCargoes(ep_loc_lastCargoFromRoute(i_loc_sub_route), i_act_cargo) + p_loc_lastLoadArrivalTime(i_loc_sub_route);
					                    ep_loc_lastCargoFromRoute(ep_route) := i_act_cargo;
					                    ep_calc_vesselOnRoute(ep_route) := i_act_vessel;
					                    p_loc_quantityOfCargos(ep_route) := p_loc_loopCount + 1;
					                    p_calc_cargoesOnRoute(ep_route, i_act_cargo_aux) := p_calc_cargoesOnRoute(i_loc_sub_route, i_act_cargo_aux);
					                    p_calc_cargoesOnRoute(ep_route, i_act_cargo) :=  p_loc_quantityOfCargos(ep_route);
					
					                    !Loading and delivering time
					                    p_calc_loadingTimeCargoRoute(i_act_cargo_aux, ep_route) := p_calc_loadingTimeCargoRoute(i_act_cargo_aux, i_loc_sub_route);
					                    p_calc_loadingTimeCargoRoute(i_act_cargo, ep_route) 
					                    :=  p_loc_travelTimeCargoes(ep_loc_lastCargoFromRoute(i_loc_sub_route), i_act_cargo) 
					                        + p_loc_lastLoadArrivalTime(i_loc_sub_route);
					
					                    !Add cargoes to route
					                    sp_loc_cargoesOnRoute(ep_route) := sp_loc_cargoesOnRoute(i_loc_sub_route) + "," + i_act_cargo;
					
					                    !Extra deliver arrival time
					                    p_loc_lastDeliverArrivalTime(ep_route) 
					                    :=  p_loc_lastLoadArrivalTime(ep_route) 
					                        + p_distanceBetweenLocations(ep_loadingPortsCargo(i_act_cargo), ep_deliveringPortsCargo(i_act_cargo));
					
					                    !Cost for the other movements
					                    p_calc_totalDaysTravel(ep_route) 
					                    :=  p_calc_totalDaysTravel(i_loc_sub_route)
					                        + p_distanceBetweenLocations(ep_deliveringPortsCargo(ep_loc_lastCargoFromRoute(ep_route)), ep_loadingPortsCargo(i_act_cargo))
					                        + p_distanceBetweenLocations(ep_loadingPortsCargo(i_act_cargo), ep_deliveringPortsCargo(i_act_cargo));
					
					                    !Cost for the other locations
					                    if ep_deliveringPortsCargo(ep_loc_lastCargoFromRoute(i_loc_sub_route)) <> ep_loadingPortsCargo(i_act_cargo) then
					                        p_calc_totalRouteLocationCost(ep_route) 
					                        :=  p_calc_totalRouteLocationCost(i_loc_sub_route)
					                            + sum(i_act_ct_cargo,  
					                                    p_locationCost(ep_loadingPortsCargo(i_act_cargo), i_act_ct_cargo) 
					                                    + p_locationCost(ep_deliveringPortsCargo(i_act_cargo), i_act_ct_cargo));
					                    else 
					                        p_calc_totalRouteLocationCost(ep_route) 
					                        :=  p_calc_totalRouteLocationCost(i_loc_sub_route)
					                            + sum(i_act_ct_cargo, p_locationCost(ep_deliveringPortsCargo(i_act_cargo), i_act_ct_cargo));                                
					                    endif;                
					
					                    !Cost for the other cargoes
					                    p_calc_totalRouteCargoCost(ep_route) 
					                    :=  p_calc_totalRouteCargoCost(i_loc_sub_route)
					                        + sum(i_act_ct_cargo, p_cargoCost(i_act_cargo, i_act_ct_cargo));
					
					                endif;
					            endfor;
					        endfor;
					
					        p_loc_loopCount += 1;
					
					    endrepeat;
					endfor;
					
					!Add the idle cost of a ship staying in the port of delevering
					for i_route do
					
					    if max(i_cargo, p_def_maxTimeWindow(i_cargo)) - p_loc_lastLoadArrivalTime(i_route) >= 0[day] then
					
					        p_calc_totalRouteIdleCost(i_route) 
					        +=  ((max(i_cargo, p_def_maxTimeWindow(i_cargo))- p_loc_lastLoadArrivalTime(i_route)))
					            * p_idleCostLocation(ep_DeliveringPortsCargo(ep_loc_lastCargoFromRoute(i_route)));
					
					    endif;
					endfor;
					
					!Activate solve button
					ui::sp_systemSecondaryActions(4,'state'):= 'active';
					
					!Changes to status bar
					ui::sp_systemStatusBar(2,'icon') := "aimms-checkmark-circle";
					ui::sp_systemStatusBar(2,'color') := "Green";
					ui::sp_systemStatusBar(2,'tooltip') := "The routes are succesfully generated.";
					ui::sp_systemStatusBar(3,'color') := "Orange";
					ui::sp_systemStatusBar(3,'icon') := "aimms-circle2";
					ui::sp_systemStatusBar(3,'tooltip') := "Data is ready, time to solve!";
					ui::sp_systemStatusBar(3,'state') := "active";
				}
				Set s_loc_subRoutes {
					SubsetOf: s_calc_feasibleRoutes;
					Index: i_loc_sub_route;
				}
				Parameter p_loc_loopCount;
			}
		}
		Section OutputModel {
			DeclarationSection Declaration_Results {
				Parameter p_Allocatedroutes {
					IndexDomain: mm::i_allcRoute;
					webui::UponChangeProcedure: pr_CalculateAllArcs;
				}
				Parameter p_CargoCostRoute {
					IndexDomain: i_act_cargo;
					Unit: $;
					Definition: {
						if i_act_cargo $ mm::v_CargoOnCharteredVessel(i_act_cargo) then
						    p_SpotCostVessel(i_act_cargo)
						else 
						    sum(i_act_ct_cargo, p_CargoCost(i_act_cargo, i_act_ct_cargo))
						endif;
					}
					webui::FlagsIdentifier: ui::sp_def_readOnly;
				}
				ElementParameter ep_CargoOnVessel {
					IndexDomain: i_act_cargo;
					Range: s_vessels;
					Definition: {
						mm::pr_determineCargoOnVessel;
					}
					Comment: "sp_CargoesOnRoute(i_allcRoute)";
					webui::FlagsIdentifier: ui::sp_def_readOnly;
				}
			}
		}
	}
	Section Integration {
		Procedure pr_importExcel {
			Body: {
				dex::GenerateDatasetMappings;
				
				!Delete old data
				empty Cargoes, Vessels, Cost_Types, Locations, Routes;
				
				!Importeren van de data
				dex::AddMapping(
				    mappingName : "ImportData", 
				    mappingFile : "./Mappings/Generated/Import-Excel.xml");
				
				dex::ReadFromFile(
				    dataFile : "data\\DataForImport_test_v2.xlsx", !Uiteindelijke variant DataForImport.xlsx
				    mappingName : "ImportData");
				
				!Activate all master data
				bp_activeCargoes(i_cargo):= 1;
				bp_activeVessels(i_vessel) := 1;
				bp_activeLocations(i_loc) := 1;
				p_AllocatedCargoes(i_act_cargo) :=1;
				
				!Activate generating routes
				ui::sp_systemSecondaryActions(3,'state'):= 'active';
				
				!Changes to status bar
				ui::sp_systemStatusBar(1,'icon') := "aimms-checkmark-circle";
				ui::sp_systemStatusBar(1,'color') := "Green";
				ui::sp_systemStatusBar(1,'tooltip') := "Data is succesfully imported.";
				ui::sp_systemStatusBar(2,'color') := "Orange";
				ui::sp_systemStatusBar(2,'icon'):= "aimms-circle2";
				ui::sp_systemStatusBar(2,'tooltip') := "Application ready to generate routes.";
				ui::sp_systemStatusBar(2,'state') := "active";
				ui::sp_systemStatusBar(3,'color') := "red";
				ui::sp_systemStatusBar(3,'icon') := "aimms-cancel-circle2";
				ui::sp_systemStatusBar(3,'tooltip') := "Model not ready to be solved.";
				ui::sp_systemStatusBar(3,'state') := 'inactive';
				
				!Open Overview dataset
				ui::sp_systemWorkflowFoldingStates(1, 4, 'openclose') := "open";
			}
		}
		Procedure pr_exportExcel {
			Body: {
				dex::AddMapping(
				    mappingName : "Import",
				    mappingFile : "./Mappings/Generated/Import-Excel.xml");
				
				dex::WriteToFile(
				    dataFile : "data\\FormatDataScheduling.xlsx",
				    mappingName : "Import");
			}
		}
		Procedure pr_emptyData;
	}
	Section WebUIVessel {
		Procedure pr_LegendRouteViz {
			Body: {
				for i_CargLocLoadRoute do
				    setelementadd(s_SortPortsRouteVis,ep_SortPortsRouteVis,sp_PortsVisualisationPageAnnotation(i_CargLocLoadRoute));
				endfor;
				
				for i_CargLocDelRoute do   
				    setelementadd(s_SortPortsRouteVis,ep_SortPortsRouteVis,sp_PortsVisualisationPageAnnotation(i_CargLocDelRoute));   
				endfor;
				
				for i_VesselPortOrigin do
				    setelementadd(s_SortPortsRouteVis,ep_SortPortsRouteVis,sp_PortsVisualisationPageAnnotation(i_VesselPortOrigin)); 
				endfor;
			}
		}
		Procedure pr_LegendCargoViz {
			Body: {
				for i_loc_load do
				    setelementadd(s_SortOfPortsCargo,ep_SortOfPortsCargo,ui::sp_def_typeOfPortsAnnotation(i_loc_load));
				endfor;
				
				for i_loc_del do   
				    setelementadd(s_SortOfPortsCargo,ep_SortOfPortsCargo,ui::sp_def_typeOfPortsAnnotation(i_loc_del));   
				endfor;
			}
		}
		DeclarationSection Declaration_Mapping_CargoData {
			Set s_SortOfPortsCargo {
				Index: i_SortOfPort;
				Parameter: ep_SortOfPortsCargo;
				Definition: pr_LegendCargoViz;
			}
			Set s_SelectedCargoesInMap {
				SubsetOf: s_def_activeCargoes;
				Index: i_selectedCargo;
				Definition: {
					{i_act_cargo | p_AllocatedCargoes(i_act_cargo)}
				}
			}
		}
		DeclarationSection Declaration_Results_page {
			Set s_SubsetRoutes {
				SubsetOf: mm::s_def_allocatedRoutes;
				Index: i_selectedRoute;
				Definition: {
					{mm::i_allcRoute | p_Allocatedroutes(mm::i_allcRoute)}
				}
				Comment: "Used by selecting routes in resultpage";
			}
		}
		DeclarationSection Declaration_Mapping_Visualisation_Route {
			Set s_CargoesOnSelectedRoutes {
				SubsetOf: s_cargoes;
				Index: i_SelectedCargoOnRoute;
				Definition: {
					{i_act_cargo|exists(i_selectedRoute|bp_def_cargoesOnRoute(i_selectedRoute, i_act_cargo))}
				}
				Comment: "{i_ActiveCargo|exists(i_selectedRoute|p_CargoesOnRouteBin(i_selectedRoute, i_ActiveCargo)}";
			}
			Set s_VesselOnSelectedRoutes {
				SubsetOf: s_vessels;
				Index: i_ActiveVesselUsed;
				Definition: {
					{i_act_vessel | exists(i_selectedRoute|ep_calc_vesselOnRoute(i_selectedRoute)=i_act_vessel)}
				}
			}
			Set s_SubsetCargoLoadingRoutePorts {
				SubsetOf: s_locations;
				Index: i_CargLocLoadRoute;
				Definition: {
					{i_Loc|exists(i_SelectedCargoOnRoute | i_Loc = ep_LoadingPortsCargo(i_SelectedCargoOnRoute))}
				}
			}
			Set s_SubsetCargoDeliveringRoutePorts {
				SubsetOf: s_locations;
				Index: i_CargLocDelRoute;
				Definition: {
					{i_Loc|exists(i_SelectedCargoOnRoute | i_Loc = ep_DeliveringPortsCargo(i_SelectedCargoOnRoute))}
				}
			}
			Set s_SubsetVesselLoadingPorts {
				SubsetOf: s_locations;
				Index: i_VesselPortOrigin;
				Definition: {
					!{i_Loc|exists(i_ActiveVessel | i_Loc = ep_LoadingPortsVessel(i_ActiveVessel)| v_IdleVessel(i_ActiveVessel)<1)}
					{i_Loc|exists(i_ActiveVesselUsed | i_Loc = ep_originPortOfVessel(i_ActiveVesselUsed))}
				}
			}
			StringParameter sp_PortsVisualisationPageAnnotation {
				IndexDomain: i_Loc;
				Definition: {
					if (i_Loc in s_SubsetCargoLoadingRoutePorts) and (i_loc in s_SubsetCargoDeliveringRoutePorts) and 
					    (i_Loc in s_SubsetVesselLoadingPorts) then
					    "AllThreePorts"
					elseif (i_Loc in s_SubsetVesselLoadingPorts) and (i_loc in s_SubsetCargoDeliveringRoutePorts) then
					    "VesAndDelPort"
					elseif (i_Loc in s_SubsetVesselLoadingPorts) and (i_loc in s_SubsetCargoLoadingRoutePorts) then
					    "VesAndLoadPort"
					elseif (i_Loc in s_SubsetVesselLoadingPorts) and (i_loc in s_SubsetCargoDeliveringRoutePorts) then
					    "LoadAndDelPort"    
					elseif i_Loc in s_SubsetVesselLoadingPorts then
					    "VesPort"
					elseif i_Loc in s_def_loadingPorts then
					    "LoadPort"
					else
					    "DelPort"
					endif;
				}
			}
			Set s_SortPortsRouteVis {
				Index: i_SortRouteVis;
				Parameter: ep_SortPortsRouteVis;
				Definition: pr_LegendRouteViz;
			}
			Parameter p_SizeRoutesLocation {
				IndexDomain: i_Loc;
				Definition: 1;
				webui::AnnotationsIdentifier: sp_PortsVisualisationPageAnnotation(i_Loc);
			}
		}
		DeclarationSection Declaration_GanttChart {
			Parameter p_DurationCargoOnRoute {
				IndexDomain: (i_act_cargo,i_route);
				Unit: day;
				Definition: (p_def_deleveringTimeCargoRoute(i_act_cargo, i_route)-p_calc_loadingTimeCargoRoute(i_act_cargo, i_route))*24;
			}
			Parameter p_LoadingTimeCargoRouteInHours {
				IndexDomain: (i_act_cargo,i_route);
				Unit: day;
				Definition: p_calc_loadingTimeCargoRoute(i_act_cargo, i_route)*24;
			}
			StringParameter sp_StartGanttChart {
				Definition: formatstring("%e",ep_StartHorizonDate);
			}
		}
		Section Arcs {
			Procedure pr_CalculateAllArcs {
				Body: {
					empty p_mapArcPerCargo, p_mapArcPerCargoConsideringPickupDropoff,p_FromBerthToCargoTest,p_FromBerthToCargo,p_MapArcPerCargoLocations,sp_RouteInformation;
					sp_RouteInformation(i_Loc,i_loc_from):=FormatString("%e <br>to<br>%s",i_Loc,i_loc_from);
					
					for i_selectedRoute do
					
					    !Calculate location from berth to the location of the loading of the first cargo
					    p_FromBerthToCargoTest(ep_originPortOfVessel(ep_calc_vesselOnRoute(i_selectedRoute)),ep_LoadingPortsCargo(first(i_act_cargo|p_calc_cargoesOnRoute(i_selectedRoute,i_act_cargo)=1))):=1;
					    mm::ep_allcRoute := i_selectedRoute;
					    s_loc_currentCargos := {i_act_cargo | p_calc_cargoesOnRoute(mm::ep_allcRoute, i_act_cargo)};
					    sp_RouteInformation(ep_originPortOfVessel(ep_calc_vesselOnRoute(i_selectedRoute)),ep_LoadingPortsCargo(first(i_act_cargo|p_calc_cargoesOnRoute(i_selectedRoute,i_act_cargo)=1)))+="<br>Picking up cargo: "+first(i_act_cargo|p_calc_cargoesOnRoute(i_selectedRoute,i_act_cargo)=1);
					
					    for i_loc_cargo | p_calc_cargoesOnRoute(i_selectedRoute, i_loc_cargo) do 
					    	!Calculate location of the loading and delivering of the cargo
					        p_MapArcPerCargoLocations(ep_LoadingPortsCargo(i_loc_cargo), ep_DeliveringPortsCargo(i_loc_cargo)) := 1;
						sp_RouteInformation(ep_LoadingPortsCargo(i_loc_cargo), ep_DeliveringPortsCargo(i_loc_cargo))+="<br>Deliver cargo: "+i_loc_cargo;
					
						!Calculate the location from delivering to the loading point of the new cargo
					        for i_loc_cargo1 | 
					                p_calc_cargoesOnRoute(i_selectedRoute, i_loc_cargo) < p_calc_cargoesOnRoute(i_selectedRoute, i_loc_cargo1) 
					                and i_loc_cargo1 <> i_loc_cargo do
					
					            p_mapArcPerCargo(i_selectedRoute, i_loc_cargo, i_loc_cargo1) := 1;
					
					            if ep_DeliveringPortsCargo(i_loc_cargo) = ep_LoadingPortsCargo(i_loc_cargo1) then
					                p_MapArcPerCargoLocations(ep_LoadingPortsCargo(i_loc_cargo1), ep_DeliveringPortsCargo(i_loc_cargo1)) := 1;
					                p_loc_aux := 1;
					            else
					                p_MapArcPerCargoLocations(ep_DeliveringPortsCargo(i_loc_cargo), ep_LoadingPortsCargo(i_loc_cargo1)) := 1;
					                p_MapArcPerCargoLocations(ep_LoadingPortsCargo(i_loc_cargo1), ep_DeliveringPortsCargo(i_loc_cargo1)) := 1;
					
					                sp_RouteInformation(ep_DeliveringPortsCargo(i_loc_cargo), ep_LoadingPortsCargo(i_loc_cargo1))+="<br>Picking up cargo: "+i_loc_cargo1;
					
					            endif;
					
					            break;
					        endfor;
					    endfor;
					endfor;
				}
				Set s_loc_currentCargos {
					SubsetOf: s_cargoes;
					Index: i_loc_cargo, i_loc_cargo1;
					OrderBy: p_calc_cargoesOnRoute(mm::ep_allcRoute, i_cargo);
				}
				Parameter p_loc_aux;
			}
			DeclarationSection Declaration_Arcs {
				StringParameter sp_CargoLoadingtoCargoDelivery {
					IndexDomain: (ui::i_loc_usag,ui::i_loc_usag2);
					Definition: {
						FormatString("%e <br>to<br>%s <br> %n Days",ui::i_loc_usag,ui::i_loc_usag2,ui::p_def_deliveringToLoadingPorts(ui::i_loc_usag,ui::i_loc_usag2));
					}
				}
				StringParameter sp_RouteInformation {
					IndexDomain: (i_loc,i_loc_from);
				}
				ElementParameter ep_AllocatedRoute {
					IndexDomain: mm::i_allcRoute;
					Range: mm::s_def_allocatedRoutes;
				}
				Parameter p_AllocatedCargoes {
					IndexDomain: i_act_cargo;
					Range: binary;
				}
				Parameter p_FromToDestination {
					IndexDomain: i_route;
				}
				Parameter p_FromBerthToCargo {
					IndexDomain: (mm::i_allcRoute,i_loc,i_loc_from);
				}
				Parameter p_FromBerthToCargoTest {
					IndexDomain: (i_Loc,i_loc_from);
					webui::TooltipIdentifier: sp_RouteInformation( i_Loc, i_loc_from );
				}
				Parameter p_MapArcPerCargoLocations {
					IndexDomain: (i_Loc,i_loc_from);
					webui::TooltipIdentifier: sp_RouteInformation;
				}
				Parameter p_mapArcPerCargo {
					IndexDomain: (mm::i_allcRoute,i_Cargo,i_cargo_aux);
					Range: binary;
				}
				Parameter p_mapArcPerCargoConsideringPickupDropoff {
					IndexDomain: (mm::i_allcRoute,i_Loc,i_loc_from);
					Range: binary;
				}
			}
		}
	}
	Procedure PostMainInitialization {
		Comment: {
			"Add initialization statements here that require that the libraries are already initialized properly,
			or add statements that require the Data Management module to be initialized."
		}
	}
	Procedure MainInitialization {
		Body: {
			
			ep_startHorizonDate := StringToElement(cal_days, CurrentToString("%c%y-%m-%d"), 0);
		}
		Comment: "Add initialization statements here that do NOT require any library being initialized already.";
	}
	Procedure MainExecution {
		Body: {
			solve mm::mp_SchedullingVessels;
			ui::sp_systemWorkFlowSteps(1,8,'workflowPageState') := "active";
			ui::sp_systemWorkFlowSteps(1,9,'workflowPageState') := "active";
			
			!Changes statusbar
			ui::sp_systemStatusBar(3,'icon') := "aimms-checkmark-circle";
			ui::sp_systemStatusBar(3,'color') := "Green";
			ui::sp_systemStatusBar(3,'tooltip') := "The model has been solved.";
			
			!Active Routes
			p_Allocatedroutes(mm::i_allcRoute) := 1;
			
			!Determine time cargoes
			mm::pr_sol_determineLoadingAndDelivering;
			
			!Na het oplossen moeten sommige waarden omgezet worden naar datums
			mm::pr_ConvertToDate;
			
			!Get the arcs
			pr_CalculateAllArcs;
		}
	}
	Procedure PreMainTermination {
		Body: {
			return DataManagementExit();
		}
		Comment: {
			"Add termination statements here that require all libraries to be still alive.
			Return 1 if you allow the termination sequence to continue.
			Return 0 if you want to cancel the termination sequence."
		}
	}
	Procedure MainTermination {
		Body: {
			return 1;
		}
		Comment: {
			"Add termination statements here that do not require all libraries to be still alive.
			Return 1 to allow the termination sequence to continue.
			Return 0 if you want to cancel the termination sequence.
			It is recommended to only use the procedure PreMainTermination to cancel the termination sequence and let this procedure always return 1."
		}
	}
	Procedure Procedure_1 {
		Body: {
			webui::IdentifierElementText('ui::sp_addEditElement') := " ";
		}
	}
}
