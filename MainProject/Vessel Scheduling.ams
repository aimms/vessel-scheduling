## ams_version=1.0

Model Main_Vessel_Schedule {
	Comment: {
		"Vessel Scheduling Application structure:
		
		The Main model focuses mostly on the data model, in section Data Model.
		
		Major steps:
		- Reading input
		  - pr_importExcel
		    Notes:
		    - Uses AimmsDEX to read Excel with annotations of identifiers.
		    - At the end, settings of Workflow and Statusbar are adapted.
		- Computations
		  - Generating Routes
		  - Costing of generated routes
		  - Optimization
		- Reporting
		
		MM: Mathematical modeling - Most computational stuff is in library MathematicalModel with prefix mm.
		
		
		UI: Most UI stuff is in library UserInterface with prefix ui.
		- status bar
		- workflow
		- pages
		  - Welcome
		    - Welcome
		    - Problem statement
		  - Data
		    - Locations
		    - Cargoes
		    - Vessel
		  - Computations
		  - Reporting"
	}
	Section Data_Model {
		Section Quantities_and_Units {
			Comment: {
				"This section contains all the units and quantities that are added automatically by AIMMS.
				It is recommended to declare all your quantities here."
			}
			Quantity SI_Time_Duration {
				BaseUnit: s;
				Conversions: {
					day->s : #-># * 86400,
					minute->s : #-># * 60,
					century->s : #-># * 3153600000,
					year->s : #-># * 31536000,
					month->s : #-># * 2628000,
					week->s : #-># * 604800,
					hour->s : #-># * 3600,
					tick->s : #-># / 100,
					second->s : #->#
				}
				Comment: "Expresses the value for the duration of periods.";
			}
			Quantity Q_Currency {
				BaseUnit: $;
			}
			Quantity SI_Length {
				BaseUnit: m;
				Conversions: km->m : #->1000*#;
				Comment: "Expresses the value of a distance.";
			}
		}
		Section Calendars {
			StringParameter sp_today;
			Calendar cal_days {
				Index: i_day;
				Unit: day;
				BeginDate: sp_def_beginDate;
				EndDate: sp_def_endDate;
				TimeslotFormat: "%c%y-%m-%d";
			}
			ElementParameter ep_startHorizonDate {
				Range: cal_days;
				Comment: "Start of modeling horizon.";
				dex::ColumnName: StartDate;
				dex::Dataset: Import;
				dex::TableName: Horizon;
			}
			ElementParameter ep_def_finishHorizonDate {
				Range: cal_days;
				Definition: max( i_act_cargo, ep_maxTimeWindow( i_act_cargo ) + ( p_def_deliveryTimeCargo(i_act_cargo) / 1[day] ) );
				Comment: "Last pickup time of cargos";
			}
			Parameter p_def_noDaysSchedule {
				Unit: day;
				Definition: {
					if ep_def_finishHorizonDate and ep_startHorizonDate then
						( ep_def_finishHorizonDate - ep_startHorizonDate ) + 1[day]
					else
						60[day]
					endif ;
				}
			}
			StringParameter sp_def_beginDate {
				Definition: "2000-01-01";
			}
			StringParameter sp_def_endDate {
				Definition: "2099-12-31";
			}
			Procedure pr_initCalendar {
				Body: {
					sp_today := CurrentToString("%c%y-%m-%d");
					ep_startHorizonDate := StringToElement(cal_days, sp_today, 0);
				}
			}
		}
		Section Cargoes {
			Set s_cargoes {
				Index: i_cargo_aux;
				Parameter: ep_cargo;
			}
			Index i_cargo {
				Range: s_cargoes;
				dex::ColumnName: Cargo;
			}
			Set s_def_activeCargoes {
				SubsetOf: s_cargoes;
				Index: i_act_cargo, i_act_cargo_aux;
				Definition: {
					{i_cargo | bp_activeCargoes(i_cargo)}
				}
			}
			Parameter bp_activeCargoes {
				IndexDomain: i_cargo;
				Range: binary;
				InitialData: 1;
			}
			Parameter p_spotCostVessel {
				IndexDomain: i_cargo;
				Unit: $;
				dex::ColumnName: Spot Cost;
				dex::Dataset: Import;
				dex::TableName: CargoData;
				webui::AnnotationsIdentifier: ui::sp_def_focusedCargo(i_cargo);
			}
			ElementParameter ep_minTimeWindow {
				IndexDomain: i_cargo;
				Range: cal_days;
				dex::ColumnName: Minimum Loading Time;
				dex::Dataset: Import;
				dex::TableName: CargoData;
				webui::AnnotationsIdentifier: ui::sp_def_focusedCargo(i_cargo);
			}
			ElementParameter ep_maxTimeWindow {
				IndexDomain: i_cargo;
				Range: cal_days;
				dex::ColumnName: Maximum Loading Time;
				dex::Dataset: Import;
				dex::TableName: CargoData;
				webui::AnnotationsIdentifier: ui::sp_def_focusedCargo(i_cargo);
			}
			ElementParameter ep_loadingPortsCargo {
				IndexDomain: i_cargo;
				Range: s_locations;
				dex::ColumnName: Loading Port;
				dex::Dataset: Import;
				dex::TableName: CargoData;
				webui::AnnotationsIdentifier: ui::sp_def_focusedCargo(i_cargo);
			}
			ElementParameter ep_deliveringPortsCargo {
				IndexDomain: i_cargo;
				Range: s_locations;
				dex::ColumnName: Delevering Port;
				dex::Dataset: Import;
				dex::TableName: CargoData;
				webui::AnnotationsIdentifier: ui::sp_def_focusedCargo(i_cargo);
			}
			Parameter p_def_deliveryTimeCargo {
				IndexDomain: i_cargo;
				Unit: day;
				Definition: {
					p_def_distanceBetweenLocations(
						ep_loadingPortsCargo(i_cargo), 
						ep_deliveringPortsCargo(i_cargo))
				}
			}
			Parameter p_cargoCost {
				IndexDomain: (i_cargo);
				Range: free;
				Unit: $;
				dex::ColumnName: Fixed Cost;
				dex::Dataset: Import;
				dex::TableName: CargoData;
				webui::AnnotationsIdentifier: ui::sp_def_focusedCargo(i_cargo);
			}
			Set s_def_loadingPorts {
				SubsetOf: s_locations;
				Index: i_locLoad;
				Definition: {
					{i_loc | exists(i_cargo | i_loc = ep_loadingPortsCargo(i_cargo))}
				}
			}
			Set s_def_deleveringPorts {
				SubsetOf: s_locations;
				Index: i_locDeliv;
				Definition: {
					{i_loc | exists(i_cargo | i_loc = ep_deliveringPortsCargo(i_cargo))}
				}
			}
			Set s_def_vesselOriginPorts {
				SubsetOf: s_locations;
				Index: i_locVess;
				Definition: {
					{i_loc | exists(i_act_vessel | i_loc = ep_originPortOfVessel(i_act_vessel))}
				}
			}
			Parameter p_def_minTimeWindow {
				IndexDomain: i_cargo;
				Unit: day;
				Definition: StringToMoment("%c%y-%m-%d", [day], ep_startHorizonDate, ep_minTimeWindow(i_cargo));
			}
			Parameter p_def_maxTimeWindow {
				IndexDomain: i_cargo;
				Unit: day;
				Definition: StringToMoment("%c%y-%m-%d", [day], ep_startHorizonDate, ep_maxTimeWindow(i_cargo));
			}
			Parameter p_def_maxDeliveryDate {
				IndexDomain: i_cargo;
				Unit: day;
				Definition: {
					p_def_maxTimeWindow(i_cargo) +
					p_def_deliveryTimeCargo(i_cargo)
				}
			}
		}
		Section Vessels {
			Set s_vessels {
				Parameter: ep_vessel;
			}
			Index i_vessel {
				Range: s_vessels;
				dex::ColumnName: Vessel;
			}
			Set s_def_activeVessels {
				SubsetOf: s_vessels;
				Index: i_act_vessel;
				Definition: {
					{i_vessel | bp_activeVessels(i_vessel)}
				}
			}
			Parameter bp_activeVessels {
				IndexDomain: i_vessel;
				Range: binary;
				InitialData: 1;
			}
			ElementParameter ep_originPortOfVessel {
				IndexDomain: i_vessel;
				Range: s_locations;
				dex::ColumnName: Port of Origin;
				dex::Dataset: Import;
				dex::TableName: VesselData;
			}
			Parameter p_sailingCost {
				IndexDomain: (i_vessel);
				Unit: $/day;
				Comment: {
					"! Fuel usage per day is 63000 gallons = 238000 liter -> 238000/100000 * â‚¬601 = 1433"
				}
				dex::ColumnName: Sailing Cost;
				dex::Dataset: Import;
				dex::TableName: VesselData;
			}
			Parameter p_def_idleCostVesselNotUsed {
				IndexDomain: i_vessel;
				Unit: $;
				Definition: {
					p_def_noDaysSchedule * 
					p_idleCostLocation( ep_originPortOfVessel( i_vessel ) )
				}
			}
			Set s_def_vesselActivities {
				Index: i_vesselActivities;
				Definition: {
					data { 
						idleNothingToDo,  ! Waiting; no more cargos to be handled for this route.
						idleWaitForCargo, ! Waiting in a port for a Cargo to become available.
						sailingPickup,    ! Sailing towards a pickup point.
						sailingDelivery   ! Sailing towards a delivery point.
					}
				}
				webui::ElementTextIdentifier: sp_vesselActivityPresentation;
			}
			ElementParameter ep_def_vesselIdleWaitCargo {
				Range: s_def_vesselActivities;
				Definition: 'idleWaitForCargo';
			}
			ElementParameter ep_def_vesselIdleRetired {
				Range: s_def_vesselActivities;
				Definition: 'idleNothingToDo';
			}
			ElementParameter ep_def_vesselSailingPickup {
				Range: s_def_vesselActivities;
				Definition: 'sailingPickup';
			}
			ElementParameter ep_def_vesselSailingDelivery {
				Range: s_def_vesselActivities;
				Definition: 'sailingDelivery';
			}
			StringParameter sp_vesselActivityPresentation {
				IndexDomain: i_vesselActivities;
				Definition: {
					data { 
						idleNothingToDo  : "Idle - Waiting for end",  ! Waiting; no more cargos to be handled for this route.
						idleWaitForCargo : "Idle - Waiting for cargo", ! Waiting in a port for a Cargo to become available.
						sailingPickup    : "Sailing to pickup point",    ! Sailing towards a pickup point.
						sailingDelivery  : "Sailing to delivery point"  ! Sailing towards a delivery point.
					}
				}
			}
		}
		Section Locations {
			Set s_locations {
				Parameter: ep_location;
			}
			Index i_loc {
				Range: s_locations;
				dex::ColumnName: Location;
			}
			Index i_loc_from {
				Range: s_locations;
				dex::ColumnName: Location (From);
			}
			Index i_loc_to {
				Range: s_locations;
				dex::ColumnName: Location (To);
			}
			Set s_def_activeLocations {
				SubsetOf: s_locations;
				Index: i_act_loc;
				Definition: {
					{i_loc | bp_activeLocations(i_loc)}
				}
			}
			Parameter bp_activeLocations {
				IndexDomain: i_loc;
				Range: binary;
				InitialData: 1;
			}
			Parameter p_latitude {
				IndexDomain: i_loc;
				dex::ColumnName: Latitude;
				dex::Dataset: Import;
				dex::TableName: LocationData;
			}
			Parameter p_longitude {
				IndexDomain: i_loc;
				dex::ColumnName: Longitude;
				dex::Dataset: Import;
				dex::TableName: LocationData;
			}
			Parameter p_idleCostLocation {
				IndexDomain: i_loc;
				Unit: $/day;
				dex::ColumnName: Idle Cost;
				dex::Dataset: Import;
				dex::TableName: LocationData;
				webui::AnnotationsIdentifier: ui::sp_def_focusedLocationFrom;
			}
			Parameter p_adminCostAtLocation {
				IndexDomain: (i_loc);
				Unit: $;
				dex::ColumnName: Admin Cost;
				dex::Dataset: Import;
				dex::TableName: LocationData;
				webui::AnnotationsIdentifier: ui::sp_def_focusedLocationFrom;
			}
			Parameter p_loadingCostAtLocation {
				IndexDomain: (i_loc);
				Unit: $;
				dex::ColumnName: Loading Cost;
				dex::Dataset: Import;
				dex::TableName: LocationData;
				webui::AnnotationsIdentifier: ui::sp_def_focusedLocationFrom;
			}
			Parameter p_vesselVelocity {
				Unit: km/hour;
				InitialData: 37.04;
				Comment: "20 knots";
			}
			Parameter p_def_harvesineDistanceBetweenLocations {
				IndexDomain: (i_loc_from,i_loc_to)| i_loc_from <> i_loc_to;
				Unit: day;
				Definition: {
					((6371.0[km])
					    * arccos(
					        cos(radians(90 - P_latitude(i_loc_from)))
					        * cos(radians(90 - P_latitude(i_loc_to)))
					        +
					        sin(radians(90 - P_latitude(i_loc_from)))
					        * sin(radians(90 - P_latitude(i_loc_to)))
					        * cos(radians(p_longitude(i_loc_from) - p_longitude(i_loc_to)))))
					/$ p_vesselVelocity
				}
			}
			Parameter p_def_distanceBetweenLocations {
				IndexDomain: (i_loc_from, i_loc_to);
				Unit: day;
				Definition: round(p_def_harvesineDistanceBetweenLocations(i_loc_from, i_loc_to),0);
			}
		}
		Section Routes {
			Set s_calc_feasibleRoutes {
				Index: i_route;
				Parameter: ep_route;
			}
			Set s_calc_legs {
				SubsetOf: Integers;
				Index: i_leg, i_leg_aux;
				Property: ElementsAreLabels;
				Definition: {
					{ 1 .. 20 }
				}
			}
			Set s_calc_usedRoutes {
				SubsetOf: s_calc_feasibleRoutes;
				Index: i_used_route;
				Comment: "The routes in the solution of the last solved mm::mp_vesselScheduling.";
			}
			Set s_calc_cargosHandled {
				IndexDomain: i_route;
				SubsetOf: s_cargoes;
				OrderBy: user;
			}
			Set s_temp_routeWorkingList {
				SubsetOf: s_calc_feasibleRoutes;
				Index: i_workRoute;
				Parameter: ep_workRoute;
				OrderBy: user;
				Comment: {
					"This set of route functions as a FIFO list;
					new routes are appended to the end, and processed from the
					beginning."
				}
			}
			ElementParameter ep_temp_lastLocation {
				IndexDomain: i_route;
				Range: s_locations;
			}
			ElementParameter ep_temp_nextSailingDay {
				IndexDomain: i_route;
				Range: cal_days;
			}
			ElementParameter ep_calc_pickupDate {
				IndexDomain: (i_route,i_cargo);
				Range: cal_days;
				Comment: "to be used for p_calc_loadingTimeCargoRoute.";
			}
			ElementParameter ep_calc_deliveryDate {
				IndexDomain: (i_route,i_cargo);
				Range: cal_days;
			}
			ElementParameter ep_calc_routeVessel {
				IndexDomain: i_route;
				Range: s_vessels;
			}
			ElementParameter ep_calc_routeLastLeg {
				IndexDomain: i_route;
				Range: s_calc_legs;
			}
			ElementParameter ep_calc_vesselActivityType {
				IndexDomain: (i_route, i_leg);
				Range: s_def_vesselActivities;
				webui::FlagsIdentifier: ui::sp_def_readOnly;
			}
			ElementParameter ep_calc_vesselActivityLocation {
				IndexDomain: (i_route,i_leg);
				Range: s_locations;
				Comment: {
					"For activities ep_vesselIdleWaitCargo and ep_vesselIdleRetired
					the location where the vessel is at.
					For activities ep_vesselSailingPickup  and ep_vesselSailingDelivery  the
					location where the vessel is sailing towards."
				}
				webui::FlagsIdentifier: ui::sp_def_readOnly;
			}
			ElementParameter ep_calc_vesselActivityFirst {
				IndexDomain: (i_route,i_leg);
				Range: cal_days;
				Comment: "First day of this vessel activity.";
				webui::FlagsIdentifier: ui::sp_def_readOnly;
			}
			ElementParameter ep_calc_vesselActivityLast {
				IndexDomain: (i_route,i_leg);
				Range: cal_days;
				webui::FlagsIdentifier: ui::sp_def_readOnly;
			}
			Parameter p_calc_arcsPerRoute {
				IndexDomain: (i_route,i_loc_from,i_loc_to);
				Range: binary;
			}
			Parameter p_def_vesselActivityLength {
				IndexDomain: (i_route,i_leg) | ep_calc_vesselActivityLast(i_route, i_leg);
				Unit: day;
				Definition: ((ep_calc_vesselActivityLast(i_route, i_leg) - ep_calc_vesselActivityFirst(i_route, i_leg)));
			}
			Parameter p_def_routeSailingDays {
				IndexDomain: i_route;
				Unit: day;
				Definition: {
					sum(i_leg | 
					        ep_calc_vesselActivityType(i_route, i_leg) = ep_def_vesselSailingPickup 
					        or ep_calc_vesselActivityType(i_route, i_leg) = ep_def_vesselSailingDelivery,
						p_def_vesselActivityLength(i_route, i_leg))
				}
			}
			Parameter p_def_routeIdleDays {
				IndexDomain: i_route;
				Unit: day;
				Definition: {
					sum( i_leg | 
						ep_calc_vesselActivityType(i_route, i_leg) = ep_def_vesselIdleWaitCargo or
						ep_calc_vesselActivityType(i_route, i_leg) = ep_def_vesselIdleRetired ,
						p_def_vesselActivityLength(i_route, i_leg) )
				}
			}
			Parameter p_def_routeSailingCost {
				IndexDomain: i_route;
				Unit: $;
				Definition: {
					p_def_routeSailingDays(i_route) 
					* p_sailingCost(ep_calc_routeVessel(i_route))
				}
			}
			Parameter p_def_visitingLocationCost {
				IndexDomain: i_route;
				Unit: $;
				Definition: {
					sum(i_leg | 
					        ep_calc_vesselActivityType(i_route, i_leg) = ep_def_vesselSailingPickup  
					        or ep_calc_vesselActivityType(i_route, i_leg) = ep_def_vesselSailingDelivery,
						p_adminCostAtLocation(ep_calc_vesselActivityLocation(i_route, i_leg)))
					+
					
					sum(i_leg | 
						    ep_calc_vesselActivityType(i_route, i_leg) = ep_def_vesselSailingPickup,
						p_loadingCostAtLocation(ep_calc_vesselActivityLocation(i_route, i_leg)))
				}
				Comment: {
					"The admin costs for visiting each location, and 
					the loading costs for visiting pickup locations."
				}
			}
			Parameter p_def_cargoCost {
				IndexDomain: i_route;
				Unit: $;
				Definition: {
					sum(i_cargo | 
					        i_cargo in s_calc_cargosHandled(i_route),
						p_cargoCost(i_cargo))
				}
			}
			Parameter p_def_routeIdleCost {
				IndexDomain: i_route;
				Unit: $;
				Definition: {
					sum(i_leg | 
					        ep_calc_vesselActivityType(i_route, i_leg) = ep_def_vesselIdleWaitCargo
					        or ep_calc_vesselActivityType(i_route, i_leg) = ep_def_vesselIdleRetired,
						p_def_vesselActivityLength(i_route, i_leg)
						* p_idleCostLocation(ep_calc_vesselActivityLocation(i_route, i_leg)))
				}
			}
			Parameter p_def_routeCosts {
				IndexDomain: i_route;
				Unit: $;
				Definition: {
					p_def_routeSailingCost(i_route) 
					+ p_def_visitingLocationCost(i_route) 
					+ p_def_cargoCost(i_route) 
					+ p_def_routeIdleCost(i_route)
				}
			}
			Parameter p_def_loadingTimeCargoRoute {
				IndexDomain: (i_act_cargo,i_route) | ep_calc_pickupDate(i_route, i_act_cargo);
				Unit: day;
				Definition: ep_calc_pickupDate(i_route, i_act_cargo) - ep_startHorizonDate;
				Comment: "the moment the cargo is loaded upon the vessel when it follows i_route.";
				webui::FlagsIdentifier: ui::sp_def_readOnly;
			}
			Parameter p_def_cargoesOnRoute {
				IndexDomain: (i_route,i_cargo);
				Range: nonnegative;
				Definition: 1 $ (i_cargo in s_calc_cargosHandled(i_route));
			}
			Parameter bp_def_cargoesOnRoute {
				IndexDomain: (i_route,i_act_cargo);
				Range: binary;
				Definition: 1 $ p_def_cargoesOnRoute(i_route,i_act_cargo);
			}
			Parameter p_def_deleveringTimeCargoRoute {
				IndexDomain: (i_act_cargo,i_route) | p_def_cargoesOnRoute(i_route,i_act_cargo);
				Unit: day;
				Definition: {
					(p_def_loadingTimeCargoRoute(i_act_cargo, i_route) 
					+ p_def_distanceBetweenLocations(ep_loadingPortsCargo(i_act_cargo), ep_deliveringPortsCargo(i_act_cargo)))
				}
				webui::FlagsIdentifier: ui::sp_def_readOnly;
			}
			Parameter bp_def_deliveringLocationsOnRoute {
				IndexDomain: (i_route,i_loc);
				Range: binary;
				Definition: {
					exists(i_leg | 
					    ep_calc_vesselActivityLocation(i_route, i_leg) = i_loc
					    and ep_calc_vesselActivityType(i_route, i_leg) = 'sailingDelivery')
				}
			}
			Parameter bp_def_loadingLocationsOnRoute {
				IndexDomain: (i_used_route,i_loc);
				Range: binary;
				Definition: {
					exists(i_leg | 
					    (ep_calc_vesselActivityLocation(i_used_route, i_leg) = i_loc
					    and ep_calc_vesselActivityType(i_used_route, i_leg) = 'sailingPickup'))
					
					or (ep_originPortOfVessel(ep_calc_routeVessel(i_used_route)) = i_loc
					    and i_loc = ep_calc_vesselActivityLocation(i_used_route, '1'))
				}
			}
			Procedure pr_calculateRoutesAndCost {
				Arguments: (bp_bulk);
				Body: {
					! Determine horizon start (is read in via Excel inp).
					! Determine horizon length (is end - start) whereby
					! horizon end is defined as the last day for delivery of any cargo.
					
					! Empty route sets, and dependent identifiers.
					pr_initRoutes(); 
					
					! For each vessel, initialize to the empty route.
					pr_initRouteSetWithVesselsOnly();
					
					if bp_bulk then
						pr_processRouteListEx();
					else
						pr_processRouteList();
					endif ;
					
					block ! create arcs for map
						empty p_calc_arcsPerRoute;
						p_calc_arcsPerRoute(i_route, ep_originPortOfVessel(ep_calc_routeVessel(i_route)), ep_calc_vesselActivityLocation(i_route, '1')) |
							(ep_originPortOfVessel(ep_calc_routeVessel(i_route)) <> ep_calc_vesselActivityLocation(i_route, '1'))
						:=  1;
						p_calc_arcsPerRoute(i_route, ep_calc_vesselActivityLocation(i_route, i_leg - 1), ep_calc_vesselActivityLocation(i_route, i_leg))|
							ep_calc_vesselActivityLocation(i_route, i_leg - 1) <> ep_calc_vesselActivityLocation(i_route, i_leg)
						:= 1;
					endblock ;
				}
				Parameter bp_bulk {
					Property: Input;
				}
			}
			Procedure pr_initRoutes {
				Body: {
					empty s_calc_feasibleRoutes  ; ! Will also empty all identifiers declared over s_calc_routes.
					cleandependents s_calc_feasibleRoutes ; ! Will also empty the element space for s_calc_feasibleRoutes.
				}
				Comment: "Empty the route set, and its element space.";
			}
			Procedure pr_initRouteSetWithVesselsOnly {
				Body: {
					ep_loc_leg := first(s_calc_legs);
					
					! For each Vessel, a feasible route is to leave it in its berth.
					for i_act_vessel do
					
						! Create empty route for this vessel.
						SetElementAdd(s_calc_feasibleRoutes, ep_loc_newRoute, FormatString("%e", i_act_vessel));
					
						! Append the new route to the working list.
						s_temp_routeWorkingList += ep_loc_newRoute;
					
						! initialize globals for each new route.
						s_calc_cargosHandled(ep_loc_newRoute) := {};
					
						ep_temp_nextSailingDay(ep_loc_newRoute) := ep_startHorizonDate;
						ep_temp_lastLocation(ep_loc_newRoute) := ep_originPortOfVessel(i_act_vessel);
					
						ep_calc_routeVessel(ep_loc_newRoute) := i_act_vessel;
						ep_calc_routeLastLeg(ep_loc_newRoute) := ep_loc_leg;
						ep_calc_vesselActivityType(ep_loc_newRoute, ep_loc_leg) := ep_def_vesselIdleRetired;
						ep_calc_vesselActivityLocation(ep_loc_newRoute, ep_loc_leg) := ep_originPortOfVessel(i_act_vessel);
						ep_calc_vesselActivityFirst(ep_loc_newRoute, ep_loc_leg) := ep_startHorizonDate;
						ep_calc_vesselActivityLast(ep_loc_newRoute, ep_loc_leg) := ep_def_finishHorizonDate;
					endfor;
				}
				ElementParameter ep_loc_newRoute {
					Range: s_calc_feasibleRoutes;
				}
				ElementParameter ep_loc_leg {
					Range: s_calc_legs;
				}
			}
			Procedure pr_processRouteList {
				Body: {
					while card(s_temp_routeWorkingList) do
						ep_loc_workingRoute := first(s_temp_routeWorkingList);
						s_temp_routeWorkingList -= ep_loc_workingRoute ;
						pr_processSingleRoute(ep_loc_workingRoute);
					endwhile;
				}
				ElementParameter ep_loc_workingRoute {
					Range: s_calc_feasibleRoutes;
				}
			}
			Procedure pr_processSingleRoute {
				Arguments: (ep_in_workingRoute);
				Body: {
					! Earliest possible arrival:
					ep_loc_arrivalDay(i_act_cargo) 
					:=  ep_temp_nextSailingDay(ep_in_workingRoute) 
					    + p_def_distanceBetweenLocations(ep_temp_lastLocation(ep_in_workingRoute), ep_loadingPortsCargo(i_act_cargo))/1[day];
					
					! Earliest possible pickup - both vessel and cargo need to be present.
					ep_loc_pickupDay(i_act_cargo) := max(ep_loc_arrivalDay(i_act_cargo), ep_minTimeWindow(i_act_cargo));
					
					! Next sailing day - after pickup the sailing to the delivery:
					ep_loc_nextSailingDay(i_act_cargo) 
					:=  ep_loc_pickupDay(i_act_cargo) 
					    + p_def_distanceBetweenLocations(ep_loadingPortsCargo(i_act_cargo), ep_deliveringPortsCargo(i_act_cargo))/1[day];
					
					for i_act_cargo | 
					        (not (i_act_cargo in s_calc_cargosHandled(ep_in_workingRoute))) 
					        and (ep_loc_pickupDay(i_act_cargo) <= ep_maxTimeWindow(i_act_cargo)) 
					        and (ep_loc_nextSailingDay(i_act_cargo) <= ep_def_finishHorizonDate) do 
					
						! The name of the new route is the same as the old route, with the name of the cargo appended.
						sp_loc_newRoute := FormatString("%e_%e", ep_in_workingRoute, i_act_cargo);
					
						! Append this route to the collection of all routes, and to the working list.
						SetElementAdd(s_calc_feasibleRoutes, ep_loc_newRoute, sp_loc_newRoute);
						s_temp_routeWorkingList += ep_loc_newRoute;
					
						! Work the globals for this new route; also copy a lot of data from the parent route.
						s_calc_cargosHandled(ep_loc_newRoute) := s_calc_cargosHandled(ep_in_workingRoute);
						s_calc_cargosHandled(ep_loc_newRoute) += i_act_cargo;
						ep_temp_nextSailingDay(ep_loc_newRoute) := ep_loc_nextSailingDay(i_act_cargo);
						ep_temp_lastLocation(ep_loc_newRoute) := ep_deliveringPortsCargo(i_act_cargo);
						ep_calc_routeVessel(ep_loc_newRoute) := ep_calc_routeVessel(ep_in_workingRoute);
						ep_calc_pickupDate(ep_loc_newRoute, i_act_cargo_aux) := ep_calc_pickupDate(ep_in_workingRoute, i_act_cargo_aux);
						ep_calc_pickupDate(ep_loc_newRoute, i_act_cargo) := ep_loc_pickupDay(i_act_cargo);
					
						! First copy legs from working route to new route.
						ep_calc_routeLastLeg(ep_loc_newRoute) := ep_calc_routeLastLeg(ep_in_workingRoute);
						ep_calc_vesselActivityType(ep_loc_newRoute, i_leg) := ep_calc_vesselActivityType(ep_in_workingRoute, i_leg);
						ep_calc_vesselActivityLocation(ep_loc_newRoute, i_leg) := ep_calc_vesselActivityLocation(ep_in_workingRoute, i_leg);
						ep_calc_vesselActivityFirst(ep_loc_newRoute, i_leg) := ep_calc_vesselActivityFirst(ep_in_workingRoute, i_leg);
						ep_calc_vesselActivityLast(ep_loc_newRoute, i_leg) := ep_calc_vesselActivityLast(ep_in_workingRoute, i_leg);
					
						! Second, append the legs for handling i_act_cargo:
						! - sailing towards pickup location, 
						! - perhaps waiting for the cargo to become available, 
						! - sailing towards delivery location.
						ep_loc_lastLeg := ep_calc_routeLastLeg(ep_loc_newRoute);
						if ep_calc_vesselActivityType(ep_loc_newRoute, ep_loc_lastLeg) <> ep_def_vesselIdleRetired then
							raise warning 
								FormatString("internal error, each route should have a last leg for awaiting the end of the horizon. ep_loc_newRoute = %e, ep_loc_lastLeg = %e", 
									ep_loc_newRoute, ep_loc_lastLeg) ;
						endif;
					
						! last leg (idle-retired) will be replaced by sailing to pickup for i_act_cargo.
						display ep_in_workingRoute, ep_temp_lastLocation(ep_in_workingRoute), ep_loadingPortsCargo(i_act_cargo);
						if ep_temp_lastLocation(ep_in_workingRoute) <> ep_loadingPortsCargo(i_act_cargo)  then
							if ep_calc_vesselActivityType( ep_loc_newRoute, ep_loc_lastLeg ) <> ep_def_vesselIdleRetired then
								 ep_loc_lastLeg += 1;
							endif ;
							ep_loc_legSailingPickup := ep_loc_lastLeg ;
							ep_calc_vesselActivityType(     ep_loc_newRoute, ep_loc_legSailingPickup ) := ep_def_vesselSailingPickup ;
							ep_calc_vesselActivityLocation( ep_loc_newRoute, ep_loc_legSailingPickup ) := ep_loadingPortsCargo(i_act_cargo) ;
							ep_calc_vesselActivityFirst(    ep_loc_newRoute, ep_loc_legSailingPickup ) := ep_calc_vesselActivityFirst( ep_loc_newRoute, ep_loc_legSailingPickup ) ; ! so no change.
							ep_calc_vesselActivityLast(     ep_loc_newRoute, ep_loc_legSailingPickup ) := ep_loc_arrivalDay( i_act_cargo ) ;
						endif ;
					
						! - perhaps waiting for the cargo to become available, 
						if ep_loc_arrivalDay(i_act_cargo) < ep_minTimeWindow(i_act_cargo) then
							! need to wait for the cargo to become available in the pickup port.
							if ep_calc_vesselActivityType(ep_loc_newRoute, ep_loc_lastLeg) <> ep_def_vesselIdleRetired then
								ep_loc_lastLeg += 1;
							endif;
							ep_loc_legWaitingCargo := ep_loc_lastLeg;
							ep_calc_vesselActivityType(ep_loc_newRoute, ep_loc_legWaitingCargo) := ep_def_vesselIdleWaitCargo;
							ep_calc_vesselActivityLocation(ep_loc_newRoute, ep_loc_legWaitingCargo) := ep_loadingPortsCargo(i_act_cargo);
							ep_calc_vesselActivityFirst(ep_loc_newRoute, ep_loc_legWaitingCargo) := ep_loc_arrivalDay(i_act_cargo); 
							ep_calc_vesselActivityLast(ep_loc_newRoute, ep_loc_legWaitingCargo) := ep_minTimeWindow(i_act_cargo);
						endif ;
					
						! - sailing towards delivery location.
						ep_loc_lastLeg += 1;
						ep_loc_legSailingDelivery := ep_loc_lastLeg;
						ep_calc_vesselActivityType(ep_loc_newRoute, ep_loc_legSailingDelivery) := ep_def_vesselSailingDelivery;
						ep_calc_vesselActivityLocation(ep_loc_newRoute, ep_loc_legSailingDelivery) := ep_deliveringPortsCargo(i_act_cargo);
						ep_calc_vesselActivityFirst(ep_loc_newRoute, ep_loc_legSailingDelivery) := ep_loc_pickupDay(i_act_cargo); 
						ep_calc_vesselActivityLast(ep_loc_newRoute, ep_loc_legSailingDelivery) := ep_loc_nextSailingDay(i_act_cargo);
					
						! - Always reserving a leg to wait till end of horizon.
						ep_loc_lastLeg += 1;
						ep_loc_legIdleRetire := ep_loc_lastLeg;
						ep_calc_vesselActivityType(ep_loc_newRoute, ep_loc_legIdleRetire) := ep_def_vesselIdleRetired;
						ep_calc_vesselActivityLocation(ep_loc_newRoute, ep_loc_legIdleRetire) := ep_deliveringPortsCargo(i_act_cargo);
						ep_calc_vesselActivityFirst(ep_loc_newRoute, ep_loc_legIdleRetire) := ep_loc_nextSailingDay(i_act_cargo); 
						ep_calc_vesselActivityLast(ep_loc_newRoute, ep_loc_legIdleRetire) := ep_def_finishHorizonDate;
					
						! - Finishing up admin.
						ep_calc_routeLastLeg(ep_loc_newRoute) := ep_loc_lastLeg;
					
					endfor;
				}
				ElementParameter ep_in_workingRoute {
					Range: s_calc_feasibleRoutes;
					Property: Input;
				}
				ElementParameter ep_loc_arrivalDay {
					IndexDomain: i_cargo;
					Range: cal_days;
				}
				ElementParameter ep_loc_pickupDay {
					IndexDomain: i_cargo;
					Range: cal_days;
				}
				ElementParameter ep_loc_nextSailingDay {
					IndexDomain: i_cargo;
					Range: cal_days;
				}
				StringParameter sp_loc_newRoute;
				ElementParameter ep_loc_newRoute {
					Range: s_calc_feasibleRoutes;
				}
				ElementParameter ep_loc_lastLeg {
					Range: s_calc_legs;
				}
				ElementParameter ep_loc_legSailingPickup {
					Range: s_calc_legs;
				}
				ElementParameter ep_loc_legWaitingCargo {
					Range: s_calc_legs;
				}
				ElementParameter ep_loc_legSailingDelivery {
					Range: s_calc_legs;
				}
				ElementParameter ep_loc_legIdleRetire {
					Range: s_calc_legs;
				}
			}
			Procedure pr_processRouteListEx {
				Body: {
					_s_inputList := s_temp_routeWorkingList ;
					s_temp_routeWorkingList := {};
					_s_processedRoutes := {};
					while card( _s_inputList ) do
					
						! Earliest possible arrival:
						_ep_loc_arrivalDay( _i_inputRoute, i_act_cargo ) := 
							ep_temp_nextSailingDay(_i_inputRoute) + 
					    		+p_def_distanceBetweenLocations(ep_temp_lastLocation(_i_inputRoute), 
					    			ep_loadingPortsCargo(i_act_cargo))/1[day];
					
						! Earliest possible pickup - both vessel and cargo need to be present.
						_ep_loc_pickupDay(_i_inputRoute, i_act_cargo) := 
							max(_ep_loc_arrivalDay(_i_inputRoute,i_act_cargo), 
								ep_minTimeWindow(i_act_cargo));
					
						! Next sailing day - after pickup the sailing to the delivery:
						_ep_loc_nextSailingDay(_i_inputRoute, i_act_cargo) := 
							_ep_loc_pickupDay(_i_inputRoute, i_act_cargo) 
							+ p_def_distanceBetweenLocations(ep_loadingPortsCargo(i_act_cargo), 
								ep_deliveringPortsCargo(i_act_cargo))/1[day];
					
						! Determine, for each (input) route, the collection of potential next locations.
						_s_next_potential_cargos( _i_inputRoute ) := { i_act_cargo |
							( not ( i_act_cargo in s_calc_cargosHandled( _i_inputRoute ) )                     ) and     ! Do not visit the same location twice.
							( _ep_loc_pickupDay( _i_inputRoute, i_act_cargo ) <= ep_maxTimeWindow(i_act_cargo) ) and     ! Be on time
							( _ep_loc_nextSailingDay(_i_inputRoute, i_act_cargo) <= ep_def_finishHorizonDate   )     } ; ! Don't deliver outside horizon.
					
						! Create the new routes.
						_ep_next_route( _i_inputRoute, _i_next_cargo ) | _i_next_cargo in _s_next_potential_cargos( _i_inputRoute ) :=
							StringToElement( s_calc_feasibleRoutes, formatString( "%e_%e", _i_inputRoute, _i_next_cargo ), create: 1);
						_ep_parent_route( _ep_next_route( _i_inputRoute, _i_next_cargo ) ) := _i_inputRoute ;
						_ep_last_cargo(   _ep_next_route( _i_inputRoute, _i_next_cargo ) ) := _i_next_cargo ;
					
						! Determine the collection of routes, for which route data need to be computed next.
						_s_processedRoutes += _s_inputList ;
						s_temp_routeWorkingList := s_calc_feasibleRoutes - _s_processedRoutes ;
					
						! Work the globals for this new route; also copy a lot of data from the parent route.
						s_calc_cargosHandled(i_workRoute) := s_calc_cargosHandled(_ep_parent_route(i_workRoute)) + _ep_last_cargo( i_workRoute );
						ep_temp_nextSailingDay( i_workRoute ) := _ep_loc_nextSailingDay( _ep_parent_route(i_workRoute), _ep_last_cargo( i_workRoute ) );
						ep_temp_lastLocation( i_workRoute ) := ep_deliveringPortsCargo( _ep_last_cargo( i_workRoute ) );
						ep_calc_routeVessel(i_workRoute) := ep_calc_routeVessel(_ep_parent_route(i_workRoute));
						_ep_tmp_pickupDate( i_route, i_act_cargo_aux ) := ep_calc_pickupDate(i_route, i_act_cargo_aux);
						ep_calc_pickupDate(i_workRoute, i_act_cargo_aux) := _ep_tmp_pickupDate(_ep_parent_route(i_workRoute), i_act_cargo_aux);
						ep_calc_pickupDate(i_workRoute, _ep_last_cargo( i_workRoute )) := _ep_loc_pickupDay(_ep_parent_route(i_workRoute),  _ep_last_cargo( i_workRoute ));
					
						! First copy legs from working route to new route.
						ep_calc_routeLastLeg(i_workRoute) := ep_calc_routeLastLeg(_ep_parent_route(i_workRoute));
						_ep_tmp_vesselActivityType(     i_route, i_leg ) := ep_calc_vesselActivityType(     i_route, i_leg );
						_ep_tmp_vesselActivityLocation( i_route, i_leg ) := ep_calc_vesselActivityLocation( i_route, i_leg );
						_ep_tmp_vesselActivityFirst(    i_route, i_leg ) := ep_calc_vesselActivityFirst(    i_route, i_leg );
						_ep_tmp_vesselActivityLast(     i_route, i_leg ) := ep_calc_vesselActivityLast(     i_route, i_leg );
						ep_calc_vesselActivityType(     i_workRoute, i_leg ) := _ep_tmp_vesselActivityType(     _ep_parent_route(i_workRoute), i_leg);
						ep_calc_vesselActivityLocation( i_workRoute, i_leg ) := _ep_tmp_vesselActivityLocation( _ep_parent_route(i_workRoute), i_leg);
						ep_calc_vesselActivityFirst(    i_workRoute, i_leg ) := _ep_tmp_vesselActivityFirst(    _ep_parent_route(i_workRoute), i_leg);
						ep_calc_vesselActivityLast(     i_workRoute, i_leg ) := _ep_tmp_vesselActivityLast(     _ep_parent_route(i_workRoute), i_leg);
					
						! Second, append the legs for handling i_act_cargo:
						! - sailing towards pickup location, 
						! - perhaps waiting for the cargo to become available, 
						! - sailing towards delivery location.
						!DebuggerBreakpoint();
						_ep_loc_lastLeg(i_workRoute) := ep_calc_routeLastLeg(_ep_parent_route(i_workRoute));
						_ep_debug_loadingPortsCargo(i_workRoute) := ep_loadingPortsCargo( _ep_last_cargo( i_workRoute ));
						_bp_tmp_SailToPickup(i_workRoute) := 
							 ep_temp_lastLocation( _ep_parent_route(i_workRoute) ) <> ep_loadingPortsCargo( _ep_last_cargo( i_workRoute ));
						!display { ep_temp_lastLocation(i_workRoute), _ep_last_cargo( i_workRoute ), _ep_debug_loadingPortsCargo( i_workRoute ), _bp_tmp_SailToPickup( i_workRoute ) } ;
						_ep_loc_lastLeg(i_workRoute) $ ( _bp_tmp_SailToPickup(i_workRoute) and 
							( ep_calc_vesselActivityType( i_workRoute, _ep_loc_lastLeg(i_workRoute) ) <> ep_def_vesselIdleRetired ) )
							+= 1 ;
						ep_calc_vesselActivityType(     i_workRoute, _ep_loc_lastLeg(i_workRoute) ) $ _bp_tmp_SailToPickup(i_workRoute) := ep_def_vesselSailingPickup ;
						ep_calc_vesselActivityLocation( i_workRoute, _ep_loc_lastLeg(i_workRoute) ) $ _bp_tmp_SailToPickup(i_workRoute) := ep_loadingPortsCargo(_ep_last_cargo( i_workRoute )) ;
						ep_calc_vesselActivityFirst(    i_workRoute, _ep_loc_lastLeg(i_workRoute) ) $ _bp_tmp_SailToPickup(i_workRoute) := ep_calc_vesselActivityFirst(    i_workRoute, _ep_loc_lastLeg(i_workRoute) ) ; ! so no change.
						ep_calc_vesselActivityLast(     i_workRoute, _ep_loc_lastLeg(i_workRoute) ) $ _bp_tmp_SailToPickup(i_workRoute) := _ep_loc_arrivalDay( _ep_parent_route(i_workRoute), _ep_last_cargo( i_workRoute ) );
					
						! - perhaps waiting for the cargo to become available, 
						_bp_tmp_WaitingForCargoAvailability(i_workRoute) := _ep_loc_arrivalDay( _ep_parent_route(i_workRoute), _ep_last_cargo( i_workRoute )) < ep_minTimeWindow(_ep_last_cargo( i_workRoute )) ;
						_ep_loc_lastLeg(i_workRoute) $ ( _bp_tmp_WaitingForCargoAvailability(i_workRoute) and 
							( ep_calc_vesselActivityType( i_workRoute, _ep_loc_lastLeg(i_workRoute) ) <> ep_def_vesselIdleRetired ) )
							+= 1 ;
						ep_calc_vesselActivityType(     i_workRoute, _ep_loc_lastLeg(i_workRoute)) $ _bp_tmp_WaitingForCargoAvailability(i_workRoute) := ep_def_vesselIdleWaitCargo;
						ep_calc_vesselActivityLocation( i_workRoute, _ep_loc_lastLeg(i_workRoute)) $ _bp_tmp_WaitingForCargoAvailability(i_workRoute) := ep_loadingPortsCargo( _ep_last_cargo( i_workRoute ) );
						ep_calc_vesselActivityFirst(    i_workRoute, _ep_loc_lastLeg(i_workRoute)) $ _bp_tmp_WaitingForCargoAvailability(i_workRoute) := _ep_loc_arrivalDay( _ep_parent_route(i_workRoute), _ep_last_cargo( i_workRoute ) ); 
						ep_calc_vesselActivityLast(     i_workRoute, _ep_loc_lastLeg(i_workRoute)) $ _bp_tmp_WaitingForCargoAvailability(i_workRoute) := ep_minTimeWindow(_ep_last_cargo( i_workRoute ));
					
						! - sailing towards delivery location.
						_ep_loc_lastLeg(i_workRoute) += 1;
						ep_calc_vesselActivityType(     i_workRoute, _ep_loc_lastLeg(i_workRoute) ) := ep_def_vesselSailingDelivery;
						ep_calc_vesselActivityLocation( i_workRoute, _ep_loc_lastLeg(i_workRoute) ) := ep_deliveringPortsCargo(                               _ep_last_cargo( i_workRoute ) );
						ep_calc_vesselActivityFirst(    i_workRoute, _ep_loc_lastLeg(i_workRoute) ) := _ep_loc_pickupDay(      _ep_parent_route(i_workRoute), _ep_last_cargo( i_workRoute ) ); 
						ep_calc_vesselActivityLast(     i_workRoute, _ep_loc_lastLeg(i_workRoute) ) := _ep_loc_nextSailingDay( _ep_parent_route(i_workRoute), _ep_last_cargo( i_workRoute ) );
					
						! - Always reserving a leg to wait till end of horizon.
						_ep_loc_lastLeg(i_workRoute) += 1;
						ep_calc_vesselActivityType(     i_workRoute, _ep_loc_lastLeg(i_workRoute)) := ep_def_vesselIdleRetired;
						ep_calc_vesselActivityLocation( i_workRoute, _ep_loc_lastLeg(i_workRoute)) := ep_deliveringPortsCargo(_ep_last_cargo( i_workRoute ));
						ep_calc_vesselActivityFirst(    i_workRoute, _ep_loc_lastLeg(i_workRoute)) := _ep_loc_nextSailingDay(_ep_parent_route(i_workRoute), _ep_last_cargo( i_workRoute )); 
						ep_calc_vesselActivityLast(     i_workRoute, _ep_loc_lastLeg(i_workRoute)) := ep_def_finishHorizonDate;
					
						! - Finishing up admin.
						ep_calc_routeLastLeg(i_workRoute) := _ep_loc_lastLeg(i_workRoute);
					
						! Move the working list again to the input list.
						_s_inputList := s_temp_routeWorkingList ;
						s_temp_routeWorkingList := {};
					
					endwhile;
				}
				Set _s_inputList {
					SubsetOf: s_calc_feasibleRoutes;
					Index: _i_inputRoute;
				}
				Set _s_processedRoutes {
					SubsetOf: s_calc_feasibleRoutes;
				}
				ElementParameter _ep_loc_arrivalDay {
					IndexDomain: (_i_inputRoute, i_cargo);
					Range: cal_days;
				}
				ElementParameter _ep_loc_pickupDay {
					IndexDomain: (_i_inputRoute,i_cargo);
					Range: cal_days;
				}
				ElementParameter _ep_loc_nextSailingDay {
					IndexDomain: (_i_inputRoute,i_cargo);
					Range: cal_days;
				}
				Set _s_next_potential_cargos {
					IndexDomain: _i_inputRoute;
					SubsetOf: s_cargoes;
				}
				Index _i_next_cargo {
					Range: s_cargoes;
				}
				ElementParameter _ep_next_route {
					IndexDomain: (_i_inputRoute,_i_next_cargo);
					Range: s_calc_feasibleRoutes;
				}
				ElementParameter _ep_parent_route {
					IndexDomain: i_route;
					Range: s_calc_feasibleRoutes;
				}
				ElementParameter _ep_last_cargo {
					IndexDomain: i_route;
					Range: s_cargoes;
				}
				ElementParameter _ep_loc_lastLeg {
					IndexDomain: i_route;
					Range: s_calc_legs;
				}
				Parameter _bp_tmp_SailToPickup {
					IndexDomain: i_route;
					Range: binary;
				}
				Parameter _bp_tmp_WaitingForCargoAvailability {
					IndexDomain: i_route;
					Range: binary;
				}
				ElementParameter _ep_debug_loadingPortsCargo {
					IndexDomain: i_workRoute;
					Range: s_locations;
				}
				ElementParameter _ep_tmp_pickupDate {
					IndexDomain: (i_route,i_cargo);
					Range: cal_days;
				}
				ElementParameter _ep_tmp_vesselActivityType {
					IndexDomain: (i_route, i_leg);
					Range: s_def_vesselActivities;
				}
				ElementParameter _ep_tmp_vesselActivityLocation {
					IndexDomain: (i_route,i_leg);
					Range: s_locations;
					Comment: {
						"For activities ep_vesselIdleWaitCargo and ep_vesselIdleRetired
						the location where the vessel is at.
						For activities ep_vesselSailingPickup  and ep_vesselSailingDelivery  the
						location where the vessel is sailing towards."
					}
				}
				ElementParameter _ep_tmp_vesselActivityFirst {
					IndexDomain: (i_route,i_leg);
					Range: cal_days;
					Comment: "First day of this vessel activity.";
				}
				ElementParameter _ep_tmp_vesselActivityLast {
					IndexDomain: (i_route,i_leg);
					Range: cal_days;
				}
			}
		}
	}
	Section App_Testing {
		Procedure pr_test {
			Body: {
				pr_test_readInput();
				pr_calculateRoutesAndCost(bp_bulk: 1);
				pr_routeGenOutput();
			}
		}
		Procedure pr_routeGenOutput {
			Body: {
				_f_outf.pagewidth := 32000;
				put _f_outf ;
				display { 
					ep_calc_pickupDate,
					ep_calc_deliveryDate
				};
				display { 
					ep_calc_vesselActivityType, 
					ep_calc_vesselActivityLocation, 
					ep_calc_vesselActivityFirst, 
					ep_calc_vesselActivityLast 
				};
				block where single_column_display := 1 ;
					display ep_calc_routeVessel ;
					display p_calc_arcsPerRoute ;
				endblock ;
				putclose ;
			}
			File _f_outf {
				Name: "oldgen.results";
				Device: Disk;
				Mode: replace;
			}
		}
		Procedure pr_routeGenRead {
			Body: {
				read from file "oldgen.results" ;
			}
		}
		Procedure pr_test_readInput {
			Body: {
				!di::pr_importExcel("data/DeftaultData - 2 cargos - 2 vessels.xlsx", 
				!	_p_stat, _sp_desc );
				! DeftaultData - 20 cargos - 7 vessels
				!di::pr_importExcel("data/DeftaultData.xlsx", 
				!	_p_stat, _sp_desc );
				di::pr_importExcel("data/DeftaultData - 20 cargos - 7 vessels.xlsx", 
					_p_stat, _sp_desc );
			}
			Parameter _p_stat;
			StringParameter _sp_desc;
		}
		Procedure MainExecution {
			Body: {
				pr_calculateRoutesAndCost(bp_bulk: 1);
				
				solve mm::mp_vesselScheduling;
				
				ui::sp_systemWorkFlowSteps(1,8,'workflowPageState') := "active";
				ui::sp_systemWorkFlowSteps(1,9,'workflowPageState') := "active";
				ui::sp_systemWorkFlowSteps(1,10,'workflowPageState') := "active";
				
				!Changes statusbar
				ui::sp_systemStatusBar(2,'icon') := "aimms-checkmark-circle";
				ui::sp_systemStatusBar(2,'color') := "Green";
				ui::sp_systemStatusBar(2,'tooltip') := "The model has been solved.";
				
				!Open Overview dataset
				ui::sp_systemWorkflowFoldingStates(1, 4, 'openclose') := "close";
				
				!Post Execution
				mm::pr_post_vesselResults;
				mm::pr_post_cargoResults;
			}
		}
	}
	Section App_Start_Finish {
		Procedure MainInitialization {
			Body: {
				ProfilerStart();
				
				pr_initCalendar;
			}
			Comment: "Add initialization statements here that do NOT require any library being initialized already.";
		}
		Procedure PostMainInitialization {
			Comment: {
				"Add initialization statements here that require that the libraries are already initialized properly,
				or add statements that require the Data Management module to be initialized."
			}
		}
		Procedure PreMainTermination {
			Body: {
				return 1;!DataManagementExit();
			}
			Comment: {
				"Add termination statements here that require all libraries to be still alive.
				Return 1 if you allow the termination sequence to continue.
				Return 0 if you want to cancel the termination sequence."
			}
		}
		Procedure MainTermination {
			Body: {
				return 1;
			}
			Comment: {
				"Add termination statements here that do not require all libraries to be still alive.
				Return 1 to allow the termination sequence to continue.
				Return 0 if you want to cancel the termination sequence.
				It is recommended to only use the procedure PreMainTermination to cancel the termination sequence and let this procedure always return 1."
			}
		}
	}
}
