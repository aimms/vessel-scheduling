## ams_version=1.0

LibraryModule MathematicalModel {
	Prefix: mm;
	Interface: MathematicalModel;
	Section Pre_Execution {
		Parameter p_def_operationalCostPerRoute {
			IndexDomain: i_route;
			Unit: $;
			Definition: {
				p_calc_totalCargoFixedCost(i_route)
				+ p_calc_totalRouteLocationCost(i_route)
				+ p_calc_totalRouteIdleCost(i_route)
				+ p_def_totalRouteMovementCost(i_route)
			}
		}
	}
	DeclarationSection VS_Constraints {
		Constraint c_assignCargoToOneVessel {
			IndexDomain: i_act_cargo;
			Definition: {
				sum(i_route | p_calc_cargoesOnRoute(i_route, i_act_cargo), 
				    v_allocateVesselToRoute(ep_calc_vesselOnRoute(i_route), i_route)) 
				+  bv_cargoOnCharteredVessel(i_act_cargo) 
				= 1
			}
		}
		Constraint c_vesselMaxOneRoute {
			IndexDomain: i_act_vessel;
			Definition: {
				sum(i_route, v_allocateVesselToRoute(i_act_vessel, i_route)) 
				+ v_idleVessel(i_act_vessel) 
				= 1
			}
		}
	}
	DeclarationSection VS_Variables {
		Variable v_allocateVesselToRoute {
			IndexDomain: (i_act_vessel,i_route) | p_def_domainAllocateVesselToRoute(i_act_vessel, i_route);
			Range: binary;
		}
		Parameter p_def_domainAllocateVesselToRoute {
			IndexDomain: (i_act_vessel,i_route);
			Range: binary;
			Property: NoSave;
			Definition: 1 $ (i_act_vessel = ep_calc_vesselOnRoute(i_route));
		}
		Variable bv_cargoOnCharteredVessel {
			IndexDomain: i_act_cargo;
			Range: binary;
		}
		Variable v_idleVessel {
			IndexDomain: i_act_vessel;
			Range: binary;
		}
	}
	DeclarationSection VS_Model {
		MathematicalProgram mp_vesselScheduling {
			Objective: v_objectiveFunction;
			Direction: minimize;
			Constraints: AllConstraints;
			Variables: AllVariables;
			Type: Automatic;
		}
		Variable v_objectiveFunction {
			Range: free;
			Unit: $;
			Definition: {
				v_totalOperationalCost
				+  v_def_totaVesselNotUsedCost
				+  sum(i_act_cargo, v_def_spotCost(i_act_cargo));
			}
		}
		Variable v_totalOperationalCost {
			Range: free;
			Unit: $;
			Definition: {
				sum((i_act_vessel,i_route), 
				    p_def_operationalCostPerRoute(i_route) 
				    * v_allocateVesselToRoute(i_act_vessel, i_route))
			}
		}
		Variable v_def_totaVesselNotUsedCost {
			Range: free;
			Unit: $;
			Definition: {
				sum(i_act_vessel, 
				    p_def_idleCostVesselNotUsed(i_act_vessel) 
				    !100[$]
				    * v_idleVessel(i_act_vessel))
			}
		}
		Variable v_def_spotCost {
			IndexDomain: (i_act_cargo);
			Range: free;
			Unit: $;
			Definition: {
				p_spotCostVessel(i_act_cargo) 
				* bv_cargoOnCharteredVessel(i_act_cargo)
			}
		}
	}
	Section Post_Execution {
		Set s_def_allocatedRoutes {
			SubsetOf: s_calc_feasibleRoutes;
			Index: i_allcRoute;
			Parameter: ep_allcRoute;
			OrderBy: ep_calc_vesselOnRoute(i_allcRoute);
			Definition: {
				{(i_route) | exists((i_act_vessel) | v_allocateVesselToRoute(i_act_vessel, i_route))};
			}
		}
		Parameter bp_def_allocatedCargoOnVesselPerRoute {
			IndexDomain: (i_act_vessel, i_route,i_act_cargo);
			Definition: {
				1 $ (v_allocateVesselToRoute(i_act_vessel, i_route) 
				        and bp_calc_cargoesOnVessel(i_act_vessel, i_act_cargo))
			}
		}
		DeclarationSection Post_Vessels {
			ElementParameter ep_calc_routeOfVessel {
				IndexDomain: i_vessel;
				Range: s_calc_feasibleRoutes;
				webui::AnnotationsIdentifier: ui::sp_def_vesselNotUsedAnnotation;
				webui::FlagsIdentifier: ui::sp_def_readOnly;
			}
			Parameter p_calc_operationalCostPerVessel {
				IndexDomain: i_vessel;
				Unit: $;
				webui::AnnotationsIdentifier: ui::sp_def_vesselNotUsedAnnotation;
				webui::FlagsIdentifier: ui::sp_def_readOnly;
			}
			Parameter p_calc_totalTravelDaysPerVessel {
				IndexDomain: i_vessel;
				Unit: day;
				webui::AnnotationsIdentifier: ui::sp_def_vesselNotUsedAnnotation;
				webui::FlagsIdentifier: ui::sp_def_readOnly;
			}
			Parameter bp_calc_cargoesOnVessel {
				IndexDomain: (i_vessel,i_act_cargo);
				Range: binary;
				webui::AnnotationsIdentifier: ui::sp_def_vesselNotUsedAnnotation;
				webui::FlagsIdentifier: ui::sp_def_readOnly;
			}
		}
		Procedure pr_post_vesselResults {
			Body: {
				empty Post_Vessels;
				
				empty _bp_routeVessel ;
				_bp_routeVessel( i_act_vessel, i_route ) := round(  v_allocateVesselToRoute(i_act_vessel, i_route) );
				ep_calc_routeOfVessel(i_act_vessel) := first(i_route | _bp_routeVessel(i_act_vessel, i_route) );
				p_calc_operationalCostPerVessel(i_act_vessel) := p_def_operationalCostPerRoute(ep_calc_routeOfVessel(i_act_vessel));
				p_calc_totalTravelDaysPerVessel(i_act_vessel) := p_calc_totalDaysTravelPerRoute(ep_calc_routeOfVessel(i_act_vessel));
				bp_calc_cargoesOnVessel(i_act_vessel, i_act_cargo) := bp_def_cargoesOnRoute(ep_calc_routeOfVessel(i_act_vessel), i_act_cargo);
				
				s_calc_routesOptimalSolution := { i_route | exists( i_act_vessel |  _bp_routeVessel(i_act_vessel, i_route) ) };
			}
			Parameter _bp_routeVessel {
				IndexDomain: (i_act_vessel,i_route);
				Range: binary;
			}
		}
		DeclarationSection Post_Cargoes {
			ElementParameter ep_calc_vesselOfCargo {
				IndexDomain: i_act_cargo;
				Range: s_vessels;
				webui::AnnotationsIdentifier: ui::sp_def_cargoNotDeliveredAnnotation;
				webui::FlagsIdentifier: ui::sp_def_readOnly;
			}
			ElementParameter ep_calc_routeOfCargo {
				IndexDomain: i_act_cargo;
				Range: s_calc_feasibleRoutes;
				webui::AnnotationsIdentifier: ui::sp_def_cargoNotDeliveredAnnotation;
				webui::FlagsIdentifier: ui::sp_def_readOnly;
			}
			Parameter p_calc_totalCostPerCargo {
				IndexDomain: i_act_cargo;
				Unit: $;
				webui::AnnotationsIdentifier: ui::sp_def_cargoNotDeliveredAnnotation;
				webui::FlagsIdentifier: ui::sp_def_readOnly;
				webui::TooltipIdentifier: ui::sp_def_cargoIsSpotTooltip;
			}
			StringParameter sp_calc_loadingTimePerCargo {
				IndexDomain: i_act_cargo;
				webui::AnnotationsIdentifier: ui::sp_def_cargoNotDeliveredAnnotation;
				webui::FlagsIdentifier: ui::sp_def_readOnly;
			}
			StringParameter sp_calc_deleveringTimePerCargo {
				IndexDomain: i_act_cargo;
				webui::AnnotationsIdentifier: ui::sp_def_cargoNotDeliveredAnnotation;
				webui::FlagsIdentifier: ui::sp_def_readOnly;
			}
		}
		Procedure pr_post_cargoResults {
			Body: {
				empty Post_Cargoes;
				
				ep_calc_vesselOfCargo(i_act_cargo) :=  first(i_vessel | bp_calc_cargoesOnVessel(i_vessel, i_act_cargo));
				ep_calc_routeOfCargo(i_act_cargo) :=  first(i_route | exists(i_act_vessel | bp_def_allocatedCargoOnVesselPerRoute(i_act_vessel, i_route, i_act_cargo)));
				
				p_calc_totalCostPerCargo(i_act_cargo) | bv_cargoOnCharteredVessel(i_act_cargo) := p_spotCostVessel(i_act_cargo);
				p_calc_totalCostPerCargo(i_act_cargo) | not p_calc_totalCostPerCargo(i_act_cargo) := sum(i_act_ct_cargo, p_cargoCost(i_act_cargo, i_act_ct_cargo));
				
				sp_calc_loadingTimePerCargo(i_act_cargo) |
				          ep_calc_routeOfCargo(i_act_cargo)
				:=  MomentToString("%d/%m/%y", [day], ep_startHorizonDate, p_calc_loadingTimeCargoRoute(i_act_cargo, ep_calc_routeOfCargo(i_act_cargo)));
				
				sp_calc_deleveringTimePerCargo(i_act_cargo) |
				        ep_calc_routeOfCargo(i_act_cargo)
				:=  MomentToString("%d/%m/%y",[day], ep_startHorizonDate, p_def_deleveringTimeCargoRoute(i_act_cargo, ep_calc_routeOfCargo(i_act_cargo)));
			}
		}
	}
	Procedure LibraryInitialization {
		Comment: "Add initialization statements here that do not require any other library being initialized already.";
	}
	Procedure PostLibraryInitialization {
		Comment: {
			"Add initialization statements here that require another library to be initialized already,
			or add statements that require the Data Management module to be initialized."
		}
	}
	Procedure PreLibraryTermination {
		Body: {
			return 1;
		}
		Comment: {
			"Add termination statements here that require all other libraries to be still alive.
			Return 1 if you allow the termination sequence to continue.
			Return 0 if you want to cancel the termination sequence."
		}
	}
	Procedure LibraryTermination {
		Body: {
			return 1;
		}
		Comment: {
			"Add termination statements here that do not require other libraries to be still alive.
			Return 1 to allow the termination sequence to continue.
			Return 0 if you want to cancel the termination sequence.
			It is recommended to only use the procedure PreLibraryTermination to cancel the termination sequence and let this procedure always return 1."
		}
	}
}
